<!DOCTYPE html>
<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalorick√° kalkulaƒçka</title>
    <!-- Odkaz na extern√≠ CSS soubor -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
</head>

<body data-app-id="{{ app_id }}" data-supabase-url="{{ supabase_url }}" data-supabase-key="{{ supabase_key }}">
    <div class="container">

        <script>
            // Debug funkce - DEFINOVAT NA ZAƒå√ÅTKU
            let debugVisible = false;
            const debugLogs = [];

            function debugLog(message) {
                console.log(message);
                debugLogs.push(message);

                const debugDiv = document.getElementById('debugConsole');
                if (debugDiv && debugVisible) {
                    debugDiv.innerHTML += message + '<br>';
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }

            function toggleDebug() {
                const debugDiv = document.getElementById('debugConsole');
                debugVisible = !debugVisible;
                debugDiv.style.display = debugVisible ? 'block' : 'none';

                if (debugVisible) {
                    debugDiv.innerHTML = debugLogs.join('<br>');
                    debugDiv.scrollTop = debugDiv.scrollHeight;
                }
            }

            // P≈ôidejte debug logy do inicializace
            debugLog("Aplikace se spou≈°t√≠...");
        </script>

        <!-- Doƒçasn√° debug tlaƒç√≠tka -->
        <div
            style="position: fixed; bottom: 30px; left: 100px; z-index: 1000; background: white; padding: 10px; border: 1px solid #ccc;">
            <button onclick="window.showProfileModal()">üêõ Zobrazit Profily</button>
            <button onclick="window.forceReloadProfiles()">üîÑ Reload z DB</button>
            <button onclick="window.testSupabaseConnection()">üß™ Test DB</button>
            <button onclick="localStorage.clear(); console.log('üßπ localStorage vyƒçi≈°tƒõn')">üßπ Clear Cache</button>
        </div>

        <button
            onclick="window.initializeSupabase().then(() => console.log('‚úÖ Supabase inicializov√°na:', !!window.supabaseClient))"
            style="position: fixed; top: 10px; left: 200px; z-index: 1000;">
            üîÑ Init Supabase
        </button>

        <!-- Indik√°tor naƒç√≠t√°n√≠ -->
        <div id="globalLoading"
            style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
            <div style="text-align: center;">
                <div style="margin-bottom: 10px;">Naƒç√≠t√°n√≠ aplikace...</div>
                <div class="loading-spinner"></div>
            </div>
        </div>

        <!-- Debug konzole p≈ô√≠mo v aplikaci -->
        <button onclick="toggleDebug()"
            style="position: fixed; bottom: 10px; right: 10px; z-index: 10000; background: red; color: white; padding: 10px;">DEBUG</button>
        <div id="debugConsole"
            style="display: none; position: fixed; bottom: 50px; right: 10px; width: 90%; height: 200px; background: black; color: lime; z-index: 10000; overflow: auto; padding: 10px; border: 2px solid red;">
        </div>


        <button id="manualInitButton"
            style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999;">
            Obnovit aplikaci
        </button>

        <!-- Nov√Ω wrapper pro statick√© z√°hlav√≠ -->
        <div class="sticky-header-wrapper">
            <div id="userIdDisplay"></div> <!-- P≈ôesunuto sem -->
            <h1>Kalorick√° kalkulaƒçka</h1>
            <!-- V lev√©m horn√≠m rohu -->
            <div id="currentProfileDisplay" style="display: none;">
                <div class="profile-display-clickable">
                    <img src="{{ url_for('static', filename='icon/profil.png') }}" alt="Profil" class="profile-icon">
                    <span id="currentProfileName">N√°zev profilu</span>
                </div>
            </div>
            <!-- Ikonka ozuben√©ho koleƒçka pro nastaven√≠ (PNG obr√°zek) -->
            <img id="settingsIcon" src="{{ url_for('static', filename='icon/nastaveni.png') }}" alt="Nastaven√≠"
                class="settings-icon">

            <!-- Kontejner pro zarovn√°n√≠ tlaƒç√≠tka "Recepty" a vyhled√°v√°n√≠ -->
            <div class="search-and-recipes-container">
                <div class="main-controls">
                    <button id="recipesButton" disabled>Recepty</button>
                    <!-- P≈ôid√°me tlaƒç√≠tko pro skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø -->
                    <button id="barcodeButton" style="margin-left: 10px;">
                        üì∑ Skenovat k√≥d
                    </button>
                </div>

                <form id="searchForm">
                    <input type="text" id="query" name="query"
                        placeholder="Zadejte n√°zev potraviny (nap≈ô. jablko, ku≈ôe)">
                    <button type="submit">Vyhledat</button>
                </form>
            </div>

            <div id="loading">Vyhled√°v√°m...</div>
            <div id="error-message" class="error"></div>
        </div>

        <div id="results">
            <!-- Zde se budou zobrazovat v√Ωsledky -->
        </div>
    </div>

    <!-- P≈ôihla≈°ovac√≠ mod√°ln√≠ okno -->
    <div id="loginModal" class="modal-overlay">
        <div class="modal-content">
            <h3>P≈ôihl√°≈°en√≠</h3>
            <div id="loginError" class="error" style="display: none;"></div>

            <input type="email" id="loginEmail" placeholder="E-mail" required>
            <input type="password" id="loginPassword" placeholder="Heslo" required>

            <div class="modal-action-buttons">
                <button id="loginBtn">P≈ôihl√°sit se</button>
                <button id="registerBtn">Registrovat</button>
            </div>
        </div>
    </div>

    <!-- Mod√°ln√≠ okno pro v√Ωbƒõr profilu -->
    <div id="profileModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeProfileModal">&times;</span>
            <h3>Spr√°va profil≈Ø</h3>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 15px; text-align: center;">
                Vyberte si profil pro ukl√°d√°n√≠ recept≈Ø a nastaven√≠
            </p>
            <div id="profileList">
                <!-- Seznam profil≈Ø se naƒçte zde -->
            </div>
            <div class="modal-action-buttons">
                <button id="createNewProfileBtn">Vytvo≈ôit nov√Ω profil</button>
            </div>
        </div>
    </div>

    <!-- Mod√°ln√≠ okno pro vytvo≈ôen√≠ nov√©ho profilu -->
    <div id="createProfileModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeCreateProfileModal">&times;</span>
            <h3>Vytvo≈ôit nov√Ω profil</h3>
            <input type="text" id="newProfileName" placeholder="Jm√©no profilu">
            <div class="create-profile-buttons">
                <button id="confirmCreateProfile">Vytvo≈ôit</button>
                <button id="cancelCreateProfile">Zru≈°it</button>

            </div>
        </div>
    </div>

    <!-- Mod√°ln√≠ okno pro detaily receptu -->
    <div id="detailsModal" class="modal-overlay">
        <div class="modal-content modal-recipe-content"> <!-- P≈ôidat t≈ô√≠du -->
            <span class="close-button">&times;</span> <!-- K≈ô√≠≈æek Z≈ÆST√ÅV√Å zde -->

            <div class="modal-recipe-scroll-container"> <!-- Nov√Ω kontejner pro scroll -->
                <div id="modalDetailsContent" class="modal-details modal-recipe-container">
                    <!-- Fixn√≠ hlaviƒçka receptu -->
                    <div class="modal-recipe-header">
                        <img id="modalHeaderImage" src="" alt="" class="modal-header-image">
                        <div class="modal-header-text">
                            <div id="modalHeaderName" class="modal-header-name">N√°zev receptu</div>
                            <div class="energy-display-group">
                                <div id="totalKcalDisplay" class="energy-header">0 kcal</div>
                                <div id="totalKjDisplay" class="energy-sub-header">0 kJ</div>
                            </div>
                        </div>
                    </div>

                    <!-- Hlavn√≠ obsah s scrollov√°n√≠m -->
                    <div class="modal-scrollable-container">
                        <div id="nutrientDetailsSection"></div>
                        <h3 class="ingredients-title">Slo≈æen√≠ receptu:</h3>
                        <div id="recipeIngredientsList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro vytvo≈ôen√≠ nov√©ho receptu -->
    <div id="createRecipeModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeCreateRecipeModal">&times;</span>
            <h3>Vytvo≈ôit nov√Ω recept</h3>
            <input type="text" id="newRecipeNameInput" placeholder="N√°zev receptu">
            <div class="create-recipe-buttons"> <!-- Nov√Ω kontejner pro tlaƒç√≠tka -->
                <button id="confirmCreateRecipeButton">Vytvo≈ôit a p≈ôidat</button>
                <button id="cancelCreateRecipeButton">Zru≈°it</button>
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro v√Ωbƒõr existuj√≠c√≠ho receptu -->
    <div id="selectRecipeModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeSelectRecipeModal">&times;</span>
            <h3>Moje recepty</h3>
            <!-- Nov√Ω element pro zobrazen√≠ poƒçtu recept≈Ø -->
            <div id="recipeCountDisplay" class="recipe-count-display"></div>
            <ul id="existingRecipesList">
                <!-- Recepty se naƒçtou zde -->
            </ul>
            <div class="recipe-list-actions">
                <!-- Tlaƒç√≠tko "P≈ôidat nov√Ω recept" je nyn√≠ skryto nebo odstranƒõno -->
                <!-- Tlaƒç√≠tko "Zav≈ô√≠t" je odstranƒõno -->
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro vlastn√≠ upozornƒõn√≠ -->
    <div id="customNotificationModal" class="modal-overlay">
        <div class="modal-content">
            <p id="customNotificationMessage"></p>
            <div class="notification-controls">
                <div id="dynamicNotificationToggleContainer" class="notification-toggle-container">
                    <!-- Dynamic toggle will be inserted here by JS -->
                </div>
                <!-- Tlaƒç√≠tka pro potvrzen√≠/zru≈°en√≠ se budou dynamicky vkl√°dat zde -->
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro nastaven√≠ -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-button" id="closeSettingsModal">&times;</span>
            <h3>Nastaven√≠</h3>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ smaz√°n√≠ receptu</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmDeleteRecipeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ smaz√°n√≠ polo≈æky</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmDeleteRecipeItemToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Potvrzen√≠ ulo≈æen√≠ zmƒõn</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmSaveChangesToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ vytvo≈ôen√≠ receptu</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeCreationToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ p≈ôid√°n√≠ potraviny</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmFoodAdditionToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ √∫spƒõ≈°n√©ho smaz√°n√≠</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeDeletionSuccessToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ chyby smaz√°n√≠</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeDeletionErrorToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <span class="setting-label">Ozn√°men√≠ √∫spƒõ≈°n√©ho ulo≈æen√≠ zmƒõn</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confirmRecipeSaveSuccessToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <!-- Nov√© mod√°ln√≠ okno pro skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø -->
    <div id="barcodeModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 90%; height: 70%;">
            <span class="close-button" id="closeBarcodeModal">&times;</span>
            <h3>Skenovat ƒç√°rov√Ω k√≥d</h3>
            <div id="barcodeScannerContainer"
                style="width: 100%; height: 80%; position: relative; display: flex; justify-content: center; align-items: center; background-color: #f0f0f0; border-radius: 8px;">
                <div id="barcodeUnsupportedMessage" style="text-align: center; padding: 20px;">
                    <p style="font-size: 18px; margin-bottom: 15px;">üîí Skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø nen√≠ v tomto prohl√≠≈æeƒçi
                        dostupn√©</p>
                    <p style="margin-bottom: 10px;">Pro skenov√°n√≠ k√≥d≈Ø fotoapar√°tem:</p>
                    <ul style="text-align: left; margin-bottom: 15px;">
                        <li>Pou≈æijte HTTPS p≈ôipojen√≠ (zabezpeƒçen√©)</li>
                        <li>Povolte p≈ô√≠stup ke kame≈ôe v prohl√≠≈æeƒçi</li>
                        <li>Zkuste modern√≠ prohl√≠≈æeƒç (Chrome, Firefox, Edge)</li>
                    </ul>
                    <p>M≈Ø≈æete tak√© zadat k√≥d ruƒçnƒõ:</p>
                    <input type="text" id="manualBarcodeInput" placeholder="Zadejte ƒç√°rov√Ω k√≥d"
                        style="padding: 10px; width: 200px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px;">
                    <button id="submitManualBarcode"
                        style="padding: 10px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Vyhledat</button>
                </div>
                <video id="barcodeVideo"
                    style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: none;"></video>
                <canvas id="barcodeCanvas" style="display: none;"></canvas>
                <div id="barcodeOverlay"
                    style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; height: 30%; border: 2px solid #4CAF50; border-radius: 8px; pointer-events: none; display: none;">
                </div>
            </div>
            <div style="margin-top: 15px; text-align: center;">
                <button id="toggleCameraButton" style="margin: 0 5px; display: none;">P≈ôepnout kameru</button>
                <button id="toggleFlashButton" style="margin: 0 5px; display: none;">Blesk</button>
            </div>
            <div id="barcodeStatus" style="text-align: center; margin-top: 10px; color: #666;"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.58.0/dist/umd/supabase.min.js"></script>

    <script type="module">

        // Glob√°ln√≠ promƒõnn√©
        let supabaseClient;
        let currentUser = null;
        let currentProfileId = null;
        let isAppInitialized = false;
        let isLoadingProfiles = false;
        let isProfileModalShowing = false;
        let isUpdatingProfileDisplay = false;

        // Inicializace glob√°ln√≠ch promƒõnn√Ωch
        window.currentUser = null;
        window.userProfiles = [];
        window.isLoadingProfiles = false;
        window.isProfileModalShowing = false;
        window.isAppInitialized = false;
        window.appInitialized = false;
        window.isCreatingProfile = false;

        function debugLog(message) {
            console.log(message);
            debugLogs.push(message);
        }

        console.log("üîç Kontrola glob√°ln√≠ch promƒõnn√Ωch...");
        console.log("üîç window.supabaseClient:", typeof window.supabaseClient);
        console.log("üîç window.currentUser:", typeof window.currentUser);
        console.log("üîç window.userProfiles:", typeof window.userProfiles);

        // Vynulovat pokud existuj√≠ probl√©my
        window.supabaseClient = null;
        window.currentUser = null;
        window.userProfiles = [];
        window.isLoadingProfiles = false;
        window.isProfileModalShowing = false;
        window.isAppInitialized = false;
        window.appInitialized = false;

        console.log("‚úÖ Glob√°ln√≠ promƒõnn√© inicializov√°ny");

        // P≈ô√≠m√° inicializace Supabase (p≈ôidejte na zaƒç√°tek)
        console.log("üöÄ RYCHL√Å INICIALIZACE SUPABASE");
        try {
            if (typeof supabase !== 'undefined') {
                const { createClient } = supabase;
                const supabaseUrl = 'https://temswelhomcndkifxbwl.supabase.co';
                const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRlbXN3ZWxob21jbmRraWZ4YndsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg3NDE3MzAsImV4cCI6MjA3NDMxNzczMH0.-f21p7Y9fOP5NGvk7f3z4ekckQDOGVNJfZ5Q9dHboyc';

                window.supabaseClient = createClient(supabaseUrl, supabaseKey);
                console.log("‚úÖ Rychl√° inicializace - window.supabaseClient:", !!window.supabaseClient);
            } else {
                console.error("‚ùå Supabase SDK nen√≠ dostupn√©");
            }
        } catch (error) {
            console.error("‚ùå Chyba rychl√© inicializace:", error);
        }


        // Hlavn√≠ inicializaƒçn√≠ funkce
        async function initializeApplication() {
            console.log("üîç P≈ôed inicializac√≠ - window.supabaseClient:", !!window.supabaseClient);
            console.log("üéØ initializeApplication vol√°na");
            console.log("üåç Environment:", {
                hostname: window.location.hostname,
                href: window.location.href,
                isLocalhost: window.location.hostname === 'localhost' || window.location.hostname === '192.168.100.156:5000',
                isNorthflank: window.location.hostname.includes('northflank')
            });

            try {
                // 1. Inicializace Supabase
                console.log("üîÑ Krok 1: Inicializace Supabase...");
                const supabaseInitialized = await window.initializeSupabase();

                console.log("üîç Po inicializaci - window.supabaseClient:", !!window.supabaseClient);
                console.log("üîç window.supabaseClient objekt:", window.supabaseClient);

                if (!supabaseInitialized) {
                    console.log("‚ö†Ô∏è Supabase inicializace selhala - pokraƒçuji v lok√°ln√≠m re≈æimu");
                }

                // 2. Kontrola autentizace
                console.log("üîÑ Krok 2: Autentizace...");
                window.currentUser = await checkAuth();

                console.log("üîç Po autentizaci - window.currentUser:", !!window.currentUser);

                if (!window.currentUser) {
                    console.log("‚ö†Ô∏è Autentizace selhala - vytv√°≈ô√≠m lok√°ln√≠ho u≈æivatele");
                    window.currentUser = createLocalUser();
                }

                // 3. Naƒçten√≠ profil≈Ø
                console.log("üîÑ Krok 3: Naƒç√≠t√°n√≠ profil≈Ø...");
                await window.loadUserProfiles();

                // 4. Pokud ≈æ√°dn√© profily, zobrazit modal
                console.log("üîÑ Krok 4: Kontrola profil≈Ø...");
                if (!window.userProfiles || window.userProfiles.length === 0) {
                    console.log("‚ÑπÔ∏è ≈Ω√°dn√© profily - zobrazuji modal za 1s");
                    setTimeout(() => {
                        console.log("üîÑ Zobrazuji profil modal...");
                        window.showProfileModal();
                    }, 1000);
                } else {
                    console.log("‚úÖ Profily nalezeny:", window.userProfiles.length);
                    // Pokud m√°me profily, naƒçtƒõte aktu√°ln√≠
                    const lastProfileId = localStorage.getItem(`userProfile_${window.currentUser.id}`);
                    if (lastProfileId) {
                        window.currentProfileId = lastProfileId;
                        await window.loadAndDisplayCurrentProfile();
                    }
                }

                // 5. Dokonƒçen√≠ inicializace
                window.isAppInitialized = true;
                console.log("‚úÖ Aplikace plnƒõ inicializov√°na");

                // 6. Povolit funkce aplikace
                const recipesButton = document.getElementById('recipesButton');
                if (recipesButton) {
                    recipesButton.disabled = false;
                    console.log("‚úÖ Tlaƒç√≠tko Recepty povoleno");
                }

            } catch (error) {
                console.error("‚ùå Chyba p≈ôi inicializaci:", error);

                // Fallback - vytvo≈ôit lok√°ln√≠ho u≈æivatele
                if (!window.currentUser) {
                    window.currentUser = createLocalUser();
                }

                // Fallback - zobrazit modal
                setTimeout(() => {
                    window.showProfileModal();
                }, 1500);

                window.isAppInitialized = true;
            }

            console.log("üéØ initializeApplication dokonƒçena");
        }

        // Inicializace Supabase - zajistƒõte glob√°ln√≠ dostupnost
        window.initializeSupabase = async function () {
            try {
                const bodyElement = document.body;
                const supabaseUrl = bodyElement.dataset.supabaseUrl;
                const supabaseKey = bodyElement.dataset.supabaseKey;

                console.log("üîó Inicializace Supabase...");
                console.log("üì° URL:", supabaseUrl);
                console.log("üîë Key dostupn√°:", !!supabaseKey);

                if (!supabaseUrl || !supabaseKey) {
                    console.error("‚ùå Chyb√≠ Supabase konfigurace");
                    return false;
                }

                if (typeof supabase === 'undefined') {
                    console.error("‚ùå Supabase SDK nen√≠ naƒçteno");
                    return false;
                }

                // VYTVO≈òIT GLOB√ÅLN√ç SUPABASE CLIENT
                const { createClient } = supabase;
                window.supabaseClient = createClient(supabaseUrl, supabaseKey, {
                    auth: {
                        persistSession: true,
                        autoRefreshToken: true,
                    }
                });

                console.log("‚úÖ Supabase klient vytvo≈ôen:", !!window.supabaseClient);
                console.log("üîç Auth klient:", !!window.supabaseClient.auth);

                // Test p≈ôipojen√≠ - jednodu≈°≈°√≠ test
                console.log("üîÑ Testuji p≈ôipojen√≠...");
                const { data, error } = await window.supabaseClient
                    .from('profiles')
                    .select('count')
                    .limit(1);

                if (error) {
                    console.error("‚ùå Test p≈ôipojen√≠ selhal:", error);
                    // Pokraƒçujeme i p≈ôi chybƒõ - m≈Ø≈æe to b√Ωt kv≈Øli RLS
                    console.log("‚ÑπÔ∏è Pokraƒçuji s lok√°ln√≠m re≈æimem");
                    return true;
                }

                console.log("‚úÖ Supabase klient inicializov√°n a p≈ôipojen");
                console.log("üîç window.supabaseClient:", !!window.supabaseClient);
                return true;

            } catch (error) {
                console.error("‚ùå Chyba p≈ôi inicializaci Supabase:", error);
                console.log("‚ÑπÔ∏è Pokraƒçuji s lok√°ln√≠m re≈æimem");
                return true; // Vrac√≠me true, aby aplikace mohla pokraƒçovat
            }
        };

        // Kontrola autentizace
        async function checkAuth() {
            console.log("üéØ checkAuth vol√°na");

            if (!window.supabaseClient) {
                console.error("‚ùå Supabase klient nen√≠ inicializov√°n");
                return createLocalUser();
            }

            try {
                console.log("üîç Kontroluji session...");

                // Kontrola, zda je auth dostupn√Ω
                if (!window.supabaseClient.auth) {
                    console.log("‚ÑπÔ∏è Auth nen√≠ dostupn√© - pou≈æ√≠v√°m lok√°ln√≠ho u≈æivatele");
                    return createLocalUser();
                }

                const { data: { session }, error } = await window.supabaseClient.auth.getSession();

                if (error) {
                    console.error("‚ùå Chyba p≈ôi kontrole session:", error);
                    return await attemptAnonymousSignIn();
                }

                if (session && session.user) {
                    console.log("‚úÖ Session nalezena, user:", session.user.id);
                    window.currentUser = session.user;
                    return session.user;
                } else {
                    console.log("‚ÑπÔ∏è ≈Ω√°dn√° session - zkou≈°√≠m anonymn√≠ p≈ôihl√°≈°en√≠");
                    return await attemptAnonymousSignIn();
                }
            } catch (error) {
                console.error("‚ùå Neoƒçek√°van√° chyba p≈ôi autentizaci:", error);
                return createLocalUser();
            }
        }

        // Pokus o anonymn√≠ p≈ôihl√°≈°en√≠
        async function attemptAnonymousSignIn() {
            try {
                console.log("üîÑ Pokus o anonymn√≠ p≈ôihl√°≈°en√≠...");

                // Kontrola, zda je auth dostupn√Ω
                if (!window.supabaseClient || !window.supabaseClient.auth) {
                    console.log("‚ÑπÔ∏è Auth nen√≠ dostupn√© - pou≈æ√≠v√°m lok√°ln√≠ho u≈æivatele");
                    return createLocalUser();
                }

                const { data, error } = await window.supabaseClient.auth.signInAnonymously();

                if (error) {
                    console.error("‚ùå Anonymn√≠ p≈ôihl√°≈°en√≠ selhalo:", error);
                    return createLocalUser();
                }

                if (data && data.user) {
                    console.log("‚úÖ Anonymn√≠ u≈æivatel p≈ôihl√°≈°en:", data.user.id);
                    window.currentUser = data.user;
                    return data.user;
                }

                throw new Error("Neplatn√° odpovƒõƒè od Supabase");

            } catch (error) {
                console.error("‚ùå Chyba p≈ôi anonymn√≠m p≈ôihl√°≈°en√≠:", error);
                return createLocalUser();
            }
        }

        // Vytvo≈ôen√≠ lok√°ln√≠ho u≈æivatele
        function createLocalUser() {
            console.log("üîÑ Vytv√°≈ô√≠m lok√°ln√≠ho u≈æivatele...");

            // Generujeme UUID form√°t m√≠sto "local-user-"
            const generateUUID = () => {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            };

            window.currentUser = {
                id: generateUUID(), // UUID form√°t
                email: null,
                is_anonymous: true,
                is_local: true
            };
            console.log("‚úÖ Lok√°ln√≠ u≈æivatel vytvo≈ôen:", window.currentUser.id);
            return window.currentUser;
        }

        async function createNewProfile(profileName) {
            // Zabr√°nit souƒçasn√©mu spu≈°tƒõn√≠ v√≠ce instanc√≠
            if (window.isCreatingProfile) {
                console.log("‚ö†Ô∏è Vytv√°≈ôen√≠ profilu ji≈æ prob√≠h√° - p≈ôeskoƒçeno");
                return null;
            }

            window.isCreatingProfile = true;

            console.log("üéØ ===== CREATE NEW PROFILE START =====");
            console.log("üìù Jm√©no profilu:", profileName);
            console.log("üë§ CurrentUser:", window.currentUser);
            console.log("üîó SupabaseClient:", !!window.supabaseClient);

            if (!profileName || profileName.trim() === '') {
                console.error("‚ùå N√°zev profilu je pr√°zdn√Ω");
                window.showCustomNotification("Pros√≠m, zadejte n√°zev profilu.", 'error');
                window.isCreatingProfile = false;
                return null;
            }

            try {
                const trimmedName = profileName.trim();
                let newProfileId = null;

                // POKUS O ULO≈ΩEN√ç DO SUPABASE (pouze pokud u≈æivatel nen√≠ lok√°ln√≠)
                if (window.supabaseClient && window.currentUser && !window.currentUser.is_local) {
                    console.log("üîÑ Pokus o ulo≈æen√≠ do Supabase...");

                    const profileData = {
                        name: trimmedName,
                        user_id: window.currentUser.id,
                        created_at: new Date().toISOString()
                    };

                    console.log("üì¶ Data pro insert:", profileData);

                    const { data, error } = await window.supabaseClient
                        .from('profiles')
                        .insert(profileData)
                        .select()
                        .single();

                    if (error) {
                        console.error("‚ùå Chyba p≈ôi ukl√°d√°n√≠ do Supabase:", error);
                    } else {
                        console.log("‚úÖ √öSPƒöCH: Profil ulo≈æen do Supabase!");
                        console.log("üìä Vr√°cen√° data:", data);
                        newProfileId = data.id;
                    }
                } else {
                    console.log("‚ÑπÔ∏è Lok√°ln√≠ u≈æivatel - ukl√°d√°m pouze lok√°lnƒõ");
                }

                // Fallback na lok√°ln√≠ ulo≈æen√≠
                if (!newProfileId) {
                    console.log("üîÑ Ukl√°d√°m lok√°lnƒõ...");
                    newProfileId = 'local-profile-' + Date.now();
                }

                const newProfile = {
                    id: newProfileId,
                    name: trimmedName,
                    user_id: window.currentUser ? window.currentUser.id : 'local-user',
                    created_at: new Date().toISOString(),
                    is_local: newProfileId.startsWith('local-')
                };

                // P≈ôid√°n√≠ do glob√°ln√≠ho seznamu
                if (!window.userProfiles) window.userProfiles = [];
                window.userProfiles.push(newProfile);

                // UKL√ÅD√ÅN√ç DO LOCALSTORAGE
                if (window.currentUser) {
                    try {
                        localStorage.setItem(`userProfiles_${window.currentUser.id}`, JSON.stringify(window.userProfiles));
                        console.log("üíæ Ulo≈æeno do localStorage pod kl√≠ƒçem:", `userProfiles_${window.currentUser.id}`);

                        // Ulo≈æen√≠ aktu√°ln√≠ho profilu
                        localStorage.setItem(`userProfile_${window.currentUser.id}`, newProfileId);
                        console.log("üíæ Aktu√°ln√≠ profil ulo≈æen:", newProfileId);
                    } catch (storageError) {
                        console.error("‚ùå Chyba localStorage:", storageError);
                    }
                }

                console.log("‚úÖ Profil √∫spƒõ≈°nƒõ vytvo≈ôen:", newProfileId);
                window.showCustomNotification(`Profil "${trimmedName}" byl √∫spƒõ≈°nƒõ vytvo≈ôen!`, 'success');
                return newProfileId;

            } catch (error) {
                console.error("‚ùå Chyba p≈ôi vytv√°≈ôen√≠ profilu:", error);
                window.showCustomNotification("Chyba p≈ôi vytv√°≈ôen√≠ profilu: " + error.message, 'error');
                return null;
            } finally {
                window.isCreatingProfile = false;
            }
        }

        // Funkce pro v√Ωbƒõr profilu
        window.selectProfile = async function (profileId) {
            try {
                console.log("üéØ selectProfile vol√°na:", profileId);
                window.currentProfileId = profileId;

                // Ulo≈æen√≠ v√Ωbƒõru
                if (window.currentUser) {
                    localStorage.setItem(`userProfile_${window.currentUser.id}`, profileId);
                }

                // Naƒçten√≠ a zobrazen√≠ n√°zvu profilu
                await window.loadAndDisplayCurrentProfile();

                // Skryt√≠ mod√°ln√≠ho okna
                const profileModal = document.getElementById('profileModal');
                if (profileModal) {
                    profileModal.style.display = 'none';
                    window.isProfileModalShowing = false;
                }

                console.log("‚úÖ Profil vybr√°n:", profileId);

            } catch (error) {
                console.error("‚ùå Chyba p≈ôi v√Ωbƒõru profilu:", error);
            }
        };

        // =============================================
        // INICIALIZACE EVENT LISTENER≈Æ
        // =============================================

        document.addEventListener('DOMContentLoaded', function () {
            console.log("‚úÖ DOM naƒçten, inicializuji event listenery...");

            // Event listener pro vytvo≈ôen√≠ profilu
            const confirmCreateProfileBtn = document.getElementById('confirmCreateProfile');
            if (confirmCreateProfileBtn) {
                console.log("‚úÖ Nalezeno tlaƒç√≠tko confirmCreateProfile");

                // Odstranƒõn√≠ v≈°ech existuj√≠c√≠ch listener≈Ø
                confirmCreateProfileBtn.replaceWith(confirmCreateProfileBtn.cloneNode(true));

                // Znovu naj√≠t tlaƒç√≠tko po clone
                const newConfirmCreateProfileBtn = document.getElementById('confirmCreateProfile');

                newConfirmCreateProfileBtn.addEventListener('click', async function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();

                    console.log("üéØ Kliknuto na vytvo≈ôen√≠ profilu - ZABR√ÅNƒöNO DUPLICITƒö");

                    // Zabr√°nit v√≠cen√°sobn√©mu kliknut√≠
                    if (this.disabled) {
                        console.log("‚ö†Ô∏è Tlaƒç√≠tko ji≈æ je disabled - p≈ôeskoƒçeno");
                        return;
                    }

                    const profileNameInput = document.getElementById('newProfileName');
                    if (profileNameInput) {
                        const profileName = profileNameInput.value.trim();
                        console.log("üìù Jm√©no profilu:", profileName);

                        if (!profileName) {
                            window.showCustomNotification("Pros√≠m, zadejte n√°zev profilu.", 'info');
                            return;
                        }

                        // Disable tlaƒç√≠tka bƒõhem vytv√°≈ôen√≠
                        this.disabled = true;
                        const originalText = this.textContent;
                        this.textContent = "Vytv√°≈ôen√≠...";

                        try {
                            const newProfileId = await createNewProfile(profileName);
                            console.log("üÜî Nov√© ID profilu:", newProfileId);

                            if (newProfileId) {
                                await window.selectProfile(newProfileId);
                                const createProfileModal = document.getElementById('createProfileModal');
                                if (createProfileModal) {
                                    createProfileModal.style.display = 'none';
                                }
                            }
                        } catch (error) {
                            console.error("‚ùå Chyba p≈ôi vytv√°≈ôen√≠ profilu:", error);
                        } finally {
                            // Re-enable tlaƒç√≠tka pouze pokud st√°le existuje
                            if (this && this.parentNode) {
                                this.disabled = false;
                                this.textContent = originalText;
                            }
                        }
                    }
                });
            } else {
                console.error("‚ùå Tlaƒç√≠tko confirmCreateProfile nebylo nalezeno!");
            }
        });

        // Vylep≈°en√° loadUserProfiles pro produkci
        window.loadUserProfiles = async function () {
            console.log("üéØ loadUserProfiles vol√°na - PRODUKCE");

            if (window.isLoadingProfiles) {
                console.log("‚ö†Ô∏è Naƒç√≠t√°n√≠ ji≈æ prob√≠h√° - p≈ôeskoƒçeno");
                return;
            }

            window.isLoadingProfiles = true;

            try {
                if (!window.currentUser) {
                    console.error("‚ùå loadUserProfiles: currentUser je undefined");
                    window.userProfiles = [];
                    return;
                }

                console.log("üë§ CurrentUser:", window.currentUser);
                console.log("üîó SupabaseClient:", !!window.supabaseClient);

                // 1. POKUS O NAƒåTEN√ç Z SUPABASE (pouze pokud u≈æivatel nen√≠ lok√°ln√≠)
                if (window.supabaseClient && !window.currentUser.is_local) {
                    try {
                        console.log("üîç Naƒç√≠t√°m ƒçerstv√° data z Supabase...");
                        console.log("üìä User ID pro query:", window.currentUser.id);

                        const { data, error } = await window.supabaseClient
                            .from('profiles')
                            .select('*')
                            .eq('user_id', window.currentUser.id)
                            .order('created_at', { ascending: true });

                        console.log("üì¶ Supabase odpovƒõƒè:", { data, error });

                        if (error) {
                            console.error("‚ùå Chyba Supabase:", error);
                        } else if (data) {
                            console.log("‚úÖ Data z Supabase:", data);
                            window.userProfiles = data;

                            // SYNCHRONIZACE: Ulo≈æit do localStorage jako cache
                            try {
                                localStorage.setItem(`userProfiles_${window.currentUser.id}`, JSON.stringify(data));
                                console.log("üíæ Data ulo≈æena do localStorage jako cache");
                            } catch (storageError) {
                                console.error("‚ùå Chyba localStorage:", storageError);
                            }

                            window.isLoadingProfiles = false;
                            return;
                        }
                    } catch (dbError) {
                        console.error("‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ z Supabase:", dbError);
                    }
                } else {
                    console.log("‚ÑπÔ∏è Lok√°ln√≠ u≈æivatel - p≈ôeskoƒçeno naƒç√≠t√°n√≠ z Supabase");
                }

                // 2. FALLBACK: Naƒçten√≠ z localStorage
                console.log("üîç Naƒç√≠t√°m z localStorage...");
                const storageKey = `userProfiles_${window.currentUser.id}`;
                const localData = localStorage.getItem(storageKey);
                console.log("üîë Storage key:", storageKey);
                console.log("üì¶ Local data:", localData);

                if (localData) {
                    try {
                        window.userProfiles = JSON.parse(localData);
                        console.log("‚úÖ Naƒçteno z localStorage:", window.userProfiles.length);
                    } catch (error) {
                        console.error("‚ùå Chyba parsov√°n√≠ localStorage:", error);
                        window.userProfiles = [];
                    }
                } else {
                    window.userProfiles = [];
                    console.log("‚ÑπÔ∏è ≈Ω√°dn√° data v localStorage");
                }

            } catch (error) {
                console.error("‚ùå Neoƒçek√°van√° chyba:", error);
                window.userProfiles = [];
            } finally {
                window.isLoadingProfiles = false;
                console.log("üéØ loadUserProfiles dokonƒçena");
                console.log("üìä Celkem profil≈Ø:", window.userProfiles.length);
            }
        };

        // Testovac√≠ funkce pro p≈ô√≠m√© vol√°n√≠ Supabase
        window.testSupabaseConnection = async function () {
            console.log("üß™ TEST: Supabase Connection");

            if (!window.supabaseClient) {
                console.error("‚ùå SupabaseClient nen√≠ dostupn√Ω");
                return;
            }

            try {
                // Test 1: Naƒçten√≠ v≈°ech profil≈Ø (bez filtru)
                console.log("üß™ TEST 1: Naƒç√≠t√°m v≈°echny profily...");
                const { data: allData, error: allError } = await window.supabaseClient
                    .from('profiles')
                    .select('*');

                console.log("üì¶ V≈°echny profily:", allData);
                console.log("‚ùå Chyba v≈°ech profil≈Ø:", allError);

                // Test 2: Naƒçten√≠ profil≈Ø pro konkr√©tn√≠ho u≈æivatele
                console.log("üß™ TEST 2: Naƒç√≠t√°m profily pro currentUser...");
                const { data: userData, error: userError } = await window.supabaseClient
                    .from('profiles')
                    .select('*')
                    .eq('user_id', window.currentUser.id);

                console.log("üì¶ User profily:", userData);
                console.log("‚ùå Chyba user profil≈Ø:", userError);

                // Test 3: Poƒçet z√°znam≈Ø
                console.log("üß™ TEST 3: Poƒçet z√°znam≈Ø...");
                const { count, error: countError } = await window.supabaseClient
                    .from('profiles')
                    .select('*', { count: 'exact', head: true });

                console.log("üìä Celkov√Ω poƒçet profil≈Ø:", count);
                console.log("‚ùå Chyba count:", countError);

            } catch (error) {
                console.error("‚ùå Test selhal:", error);
            }
        };

        // Synchronizace lok√°ln√≠ch dat s Supabase (voliteln√©)
        async function syncLocalDataWithSupabase() {
            if (!supabaseClient || currentUser.is_anonymous) {
                return;
            }

            try {
                // Synchronizace profil≈Ø
                const localProfiles = userProfiles.filter(p => p.is_local);
                for (const profile of localProfiles) {
                    const { data, error } = await supabaseClient
                        .from('profiles')
                        .insert({
                            name: profile.name,
                            user_id: currentUser.id
                        })
                        .select()
                        .single();

                    if (!error) {
                        // Aktualizovat ID profilu
                        profile.id = data.id;
                        profile.is_local = false;
                        debugLog("‚úÖ Profil synchronizov√°n: " + profile.name);
                    }
                }

                // Ulo≈æit aktualizovan√© profily
                localStorage.setItem(`userProfiles_${currentUser.id}`, JSON.stringify(userProfiles));

            } catch (error) {
                debugLog("‚ùå Chyba p≈ôi synchronizaci: " + error.message);
            }
        }

        // P≈ôidejte dal≈°√≠ ƒçast√© chyby ƒçten√≠

        let currentSearchXHR = null;
        let currentSearchController = null;
        let currentReader = null;
        let isSearchInterrupted = false;
        let app, db, auth, userId;
        let isAuthReady = false;
        let userSettings = {
            confirmRecipeCreation: true, // Default value
            confirmFoodAddition: true, // Default value
            confirmDeleteRecipe: true, // New default value for delete confirmation
            confirmDeleteRecipeItem: true, // New setting for deleting recipe items
            confirmSaveChanges: true, // Re-added
            confirmRecipeSaveSuccess: true, // Re-added
            confirmRecipeDeletionSuccess: true, // New setting for success message
            confirmRecipeDeletionError: true // New setting for error message
        };

        // Declare currentFoodItemData in global scope
        let currentFoodItemData = null; // To store data of the food item being processed
        let currentEditingRecipeId = null; // Store the ID of the recipe being edited
        let currentEditingIngredientIndex = null; // Store the index of the ingredient being edited
        const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}"; // Add this line

        // Glob√°ln√≠ promƒõnn√© pro spr√°vu profil≈Ø
        let userProfiles = [];
        let isCreatingProfile = false;

        // Funkce pro otev≈ôen√≠ mod√°ln√≠ho okna profilu
        function openProfileModalFromDisplay() {
            if (isAppInitialized && userId) {
                showProfileModal();
            }
        }

        // Event listener pro kliknut√≠ na profil
        document.addEventListener('DOMContentLoaded', function () {
            const profileDisplay = document.getElementById('currentProfileDisplay');

            if (profileDisplay) {
                profileDisplay.addEventListener('click', function (e) {
                    // Zabr√°n√≠me propagaci eventu, aby se neaktivovalo kliknut√≠ mimo mod√°ln√≠ okno
                    e.stopPropagation();
                    openProfileModalFromDisplay();
                });
            }
        });

        function closeModal() {
            const modal = document.getElementById('detailsModal');
            modal.style.display = 'none';
            modal.classList.remove('modal-recipe-open'); // V≈ædy odstranit p≈ôi zav≈ôen√≠
        }

        // Naƒçten√≠ a zobrazen√≠ aktu√°ln√≠ho profilu
        window.loadAndDisplayCurrentProfile = async function () {
            if (!window.currentProfileId) {
                window.hideCurrentProfileDisplay();
                return;
            }

            try {
                const profile = window.userProfiles.find(p => p.id === window.currentProfileId);
                if (profile) {
                    window.updateCurrentProfileDisplay(profile.name);
                } else {
                    window.hideCurrentProfileDisplay();
                }
            } catch (error) {
                console.error("‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ profilu:", error);
                window.hideCurrentProfileDisplay();
            }
        };
        function checkInitialization() {
            if (!isAppInitialized || !db || !userId || !currentProfileId) {
                window.showCustomNotification("Pros√≠m, poƒçkejte, ne≈æ se aplikace plnƒõ inicializuje.", 'info');
                return false;
            }
            return true;
        }

        function showGlobalLoading() {
            document.getElementById('globalLoading').style.display = 'block';
        }

        function hideGlobalLoading() {
            document.getElementById('globalLoading').style.display = 'none';
        }

        // Ulo≈æen√≠ p≈ôihla≈°ovac√≠ch √∫daj≈Ø do localStorage
        function saveLoginSession(user) {
            localStorage.setItem('userData', JSON.stringify({
                uid: user.uid,
                email: user.email,
                lastLogin: new Date().toISOString()
            }));
        }

        // Kontrola existuj√≠c√≠ relace
        function checkExistingSession() {
            const userData = localStorage.getItem('userData');
            if (userData) {
                return JSON.parse(userData);
            }
            return null;
        }

        // Funkce pro registraci
        async function registerUser(email, password) {
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                console.log("U≈æivatel zaregistrov√°n:", userCredential.user.uid);
                return userCredential.user;
            } catch (error) {
                console.error("Chyba registrace:", error);
                throw error;
            }
        }

        // Funkce pro p≈ôihl√°≈°en√≠
        async function loginUser(email, password) {
            try {
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                console.log("U≈æivatel p≈ôihl√°≈°en:", userCredential.user.uid);
                return userCredential.user;
            } catch (error) {
                console.error("Chyba p≈ôihl√°≈°en√≠:", error);
                throw error;
            }
        }

        // Funkce pro odhl√°≈°en√≠
        async function logoutUser() {
            try {
                await signOut(auth);
                console.log("U≈æivatel odhl√°≈°en");
                hideCurrentProfileDisplay(); // Skryt√≠ profilu p≈ôi odhl√°≈°en√≠
            } catch (error) {
                console.error("Chyba odhl√°≈°en√≠:", error);
            }
        }

        // Funkce pro zobrazen√≠ mod√°ln√≠ho okna pro vytvo≈ôen√≠ nov√©ho profilu
        window.showCreateProfileModal = function () {
            console.log("üéØ showCreateProfileModal vol√°na");

            const createProfileModal = document.getElementById('createProfileModal');
            const newProfileNameInput = document.getElementById('newProfileName');

            if (newProfileNameInput) {
                newProfileNameInput.addEventListener('keypress', function (event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        event.stopPropagation();
                        console.log("üéØ Enter stisknut v inputu - spou≈°t√≠m vytv√°≈ôen√≠");
                        document.getElementById('confirmCreateProfile').click();
                    }
                });
            }

            if (!createProfileModal) {
                console.error("‚ùå createProfileModal element not found!");
                return;
            }

            // Zkontrolujte, zda mod√°ln√≠ okno ji≈æ je zobrazeno
            if (createProfileModal.style.display === 'flex') {
                console.log("‚ÑπÔ∏è Create profile modal already shown");
                return;
            }

            // Resetovat vstupn√≠ pole
            if (newProfileNameInput) {
                newProfileNameInput.value = '';
            }

            // Zobrazit mod√°ln√≠ okno
            createProfileModal.style.display = 'flex';
            console.log("‚úÖ Create profile modal zobrazen");

            // Focus na vstupn√≠ pole
            setTimeout(() => {
                if (newProfileNameInput) {
                    newProfileNameInput.focus();
                    console.log("üéØ Focus na input field");
                }
            }, 100);
        };

        // Validace inputu
        document.getElementById('newProfileName').addEventListener('input', function (e) {
            const confirmBtn = document.getElementById('confirmCreateProfile');
            confirmBtn.disabled = e.target.value.trim().length === 0;
        });

        // Funkce pro zobrazen√≠ mod√°ln√≠ho okna s profily - mus√≠ b√Ωt glob√°ln√≠
        window.showProfileModal = async function () {
            console.log("üéØ showProfileModal vol√°na");

            // Zabr√°nit v√≠cen√°sobn√©mu zobrazen√≠
            if (window.isProfileModalShowing) {
                console.log("‚ö†Ô∏è Modal ji≈æ je zobrazen - p≈ôeskoƒçeno");
                return;
            }

            const profileModal = document.getElementById('profileModal');
            if (!profileModal) {
                console.error("‚ùå Profile modal element not found!");
                return;
            }

            window.isProfileModalShowing = true;

            try {
                console.log("üîÑ P≈ô√≠prava mod√°ln√≠ho okna...");

                // Naƒçten√≠ existuj√≠c√≠ch profil≈Ø
                await window.loadUserProfiles();

                // Vytvo≈ôen√≠ seznamu profil≈Ø
                const profileList = document.getElementById('profileList');
                if (profileList) {
                    profileList.innerHTML = '';

                    if (!window.userProfiles || window.userProfiles.length === 0) {
                        profileList.innerHTML = '<div class="no-profiles">≈Ω√°dn√© profily nenalezeny</div>';
                        console.log("‚ÑπÔ∏è ≈Ω√°dn√© profily k zobrazen√≠");
                    } else {
                        console.log("üìä Zobrazuji profily:", window.userProfiles.length);
                        window.userProfiles.forEach(profile => {
                            const profileItem = document.createElement('div');
                            profileItem.classList.add('profile-item');
                            if (profile.id === window.currentProfileId) {
                                profileItem.classList.add('active');
                            }

                            profileItem.innerHTML = `
                        <span class="profile-name">${profile.name}</span>
                        <span class="profile-delete" data-profile-id="${profile.id}">üóëÔ∏è</span>
                    `;

                            profileItem.addEventListener('click', (e) => {
                                if (!e.target.classList.contains('profile-delete')) {
                                    window.selectProfile(profile.id);
                                    profileModal.style.display = 'none';
                                }
                            });

                            // Event listener pro smaz√°n√≠
                            const deleteBtn = profileItem.querySelector('.profile-delete');
                            if (deleteBtn) {
                                deleteBtn.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const profileId = e.target.dataset.profileId;
                                    if (profileId && confirm('Opravdu chcete smazat tento profil?')) {
                                        window.deleteProfile(profileId);
                                    }
                                });
                            }

                            profileList.appendChild(profileItem);
                        });
                    }
                }

                // Zobrazen√≠ modalu
                profileModal.style.display = 'flex';
                console.log("‚úÖ Profile modal zobrazen");

                // Event listener pro zav≈ôen√≠ modalu
                const closeModal = function (event) {
                    if (event.target === profileModal || event.target.classList.contains('close-button')) {
                        profileModal.style.display = 'none';
                        window.isProfileModalShowing = false;
                    }
                };

                profileModal.addEventListener('click', closeModal);

            } catch (error) {
                console.error("‚ùå Error showing profile modal:", error);
                window.isProfileModalShowing = false;
            }
        };

        // Zobrazen√≠ aktu√°ln√≠ho profilu
        window.updateCurrentProfileDisplay = function (profileName) {
            const profileDisplay = document.getElementById('currentProfileDisplay');
            const profileNameSpan = document.getElementById('currentProfileName');

            if (profileDisplay && profileNameSpan) {
                profileNameSpan.textContent = profileName;
                profileDisplay.style.display = 'flex';
                console.log("‚úÖ Zobrazen√≠ profilu aktualizov√°no:", profileName);
            }
        };

        // Skryt√≠ zobrazen√≠ profilu
        window.hideCurrentProfileDisplay = function () {
            const profileDisplay = document.getElementById('currentProfileDisplay');
            if (profileDisplay) {
                profileDisplay.style.display = 'none';
            }
        };

        // Naƒçten√≠ dat profilu
        async function loadProfileData() {
            if (!currentProfileId) return;
            debugLog("üîÑ Naƒç√≠t√°m data profilu: " + currentProfileId);

            // Zde m≈Ø≈æete naƒç√≠st nastaven√≠, recepty, etc.
            await loadUserSettings();
            await loadUserRecipes();
        }

        // Funkce pro smaz√°n√≠ profilu
        window.deleteProfile = async function (profileId) {  // P≈ôid√°no async
            if (!confirm("Opravdu chcete smazat tento profil? V≈°echna data budou nen√°vratnƒõ ztracena.")) {
                return;
            }

            console.log("üóëÔ∏è Maz√°n√≠ profilu:", profileId);

            try {
                // SMƒöZ√ÅN√ç Z SUPABASE
                if (window.supabaseClient && !profileId.startsWith('local-')) {
                    try {
                        console.log("üîÑ Ma≈æu z Supabase...");
                        const { error } = await window.supabaseClient
                            .from('profiles')
                            .delete()
                            .eq('id', profileId);

                        if (error) {
                            console.error("‚ùå Chyba p≈ôi maz√°n√≠ z Supabase:", error);
                            throw error;
                        }
                        console.log("‚úÖ Profil smaz√°n z Supabase");
                    } catch (dbError) {
                        console.error("‚ùå Selhalo maz√°n√≠ z Supabase:", dbError);
                        // Pokraƒçujeme v lok√°ln√≠m maz√°n√≠
                    }
                }

                // MAZ√ÅN√ç Z LOCALSTORAGE
                console.log("üîÑ Ma≈æu z localStorage...");

                // Odstranit z pole userProfiles
                window.userProfiles = window.userProfiles.filter(profile => profile.id !== profileId);

                // Ulo≈æit aktualizovan√© pole
                if (window.currentUser) {
                    localStorage.setItem(`userProfiles_${window.currentUser.id}`, JSON.stringify(window.userProfiles));
                }

                // Feedback pro u≈æivatele
                window.showCustomNotification("Profil byl √∫spƒõ≈°nƒõ smaz√°n", 'success');

                // Naƒçten√≠ aktualizovan√©ho seznamu profil≈Ø
                await window.loadUserProfiles();

                // Pokud byl smaz√°n aktu√°ln√≠ profil, vyberte jin√Ω nebo vytvo≈ôte nov√Ω
                if (window.currentProfileId === profileId) {
                    window.currentProfileId = null;

                    if (window.currentUser) {
                        localStorage.removeItem(`userProfile_${window.currentUser.id}`);
                    }

                    if (window.userProfiles.length > 0) {
                        await window.selectProfile(window.userProfiles[0].id);
                    } else {
                        window.showCreateProfileModal();
                    }
                }

                // Obnoven√≠ zobrazen√≠ profil≈Ø
                await window.showProfileModal();

            } catch (error) {
                console.error("Chyba p≈ôi maz√°n√≠ profilu:", error);
                window.showCustomNotification("Chyba p≈ôi maz√°n√≠ profilu: " + error.message, 'error');
            }
        };

        // Funkce pro aktualizaci UI podle nastaven√≠
        function updateSettingsUI() {
            // Aktualizace p≈ôep√≠naƒç≈Ø v nastaven√≠
            const confirmRecipeCreationToggle = document.getElementById('confirmRecipeCreationToggle');
            const confirmFoodAdditionToggle = document.getElementById('confirmFoodAdditionToggle');
            const confirmDeleteRecipeToggle = document.getElementById('confirmDeleteRecipeToggle');
            const confirmDeleteRecipeItemToggle = document.getElementById('confirmDeleteRecipeItemToggle');
            const confirmSaveChangesToggle = document.getElementById('confirmSaveChangesToggle');
            const confirmRecipeSaveSuccessToggle = document.getElementById('confirmRecipeSaveSuccessToggle');
            const confirmRecipeDeletionSuccessToggle = document.getElementById('confirmRecipeDeletionSuccessToggle');
            const confirmRecipeDeletionErrorToggle = document.getElementById('confirmRecipeDeletionErrorToggle');

            if (confirmRecipeCreationToggle) confirmRecipeCreationToggle.checked = userSettings.confirmRecipeCreation;
            if (confirmFoodAdditionToggle) confirmFoodAdditionToggle.checked = userSettings.confirmFoodAddition;
            if (confirmDeleteRecipeToggle) confirmDeleteRecipeToggle.checked = userSettings.confirmDeleteRecipe;
            if (confirmDeleteRecipeItemToggle) confirmDeleteRecipeItemToggle.checked = userSettings.confirmDeleteRecipeItem;
            if (confirmSaveChangesToggle) confirmSaveChangesToggle.checked = userSettings.confirmSaveChanges;
            if (confirmRecipeSaveSuccessToggle) confirmRecipeSaveSuccessToggle.checked = userSettings.confirmRecipeSaveSuccess;
            if (confirmRecipeDeletionSuccessToggle) confirmRecipeDeletionSuccessToggle.checked = userSettings.confirmRecipeDeletionSuccess;
            if (confirmRecipeDeletionErrorToggle) confirmRecipeDeletionErrorToggle.checked = userSettings.confirmRecipeDeletionError;
        }

        // Funkce pro bezpeƒçn√© p≈ôid√°n√≠ event listeneru
        function addEventListenerOnce(elementId, eventType, callback) {
            const element = document.getElementById(elementId);
            if (!element) return;

            // Odstranƒõn√≠ existuj√≠c√≠ch listener≈Ø
            element.removeEventListener(eventType, callback);

            // P≈ôid√°n√≠ nov√©ho listeneru
            element.addEventListener(eventType, callback);
        }

        // Pou≈æit√≠:
        addEventListenerOnce('confirmCreateProfile', 'click', async () => {
            const profileName = document.getElementById('newProfileName').value.trim();
            if (profileName) {
                const newProfileId = await createNewProfile(profileName);
                if (newProfileId) {
                    await selectProfile(newProfileId);
                    document.getElementById('createProfileModal').style.display = 'none';
                }
            }
        });


        async function loadUserSettings() {

            if (!db || !userId || !currentProfileId) {
                console.error("Firestore, User ID or Profile ID not initialized.");
                return;
            }

            try {
                const settingsDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/settings/userSettings`);
                const settingsSnap = await getDoc(settingsDocRef);

                if (settingsSnap.exists()) {
                    userSettings = settingsSnap.data();
                    updateSettingsUI();
                } else {
                    // Vytvo≈ôit v√Ωchoz√≠ nastaven√≠, pokud neexistuje
                    await setDoc(settingsDocRef, userSettings);
                }
            } catch (error) {
                console.error("Chyba p≈ôi naƒç√≠t√°n√≠ nastaven√≠:", error);
            }
        }

        // Debounce funkce pro omezen√≠ ƒçetnosti vol√°n√≠
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Aplikujte debounce na event listener
        const debouncedCreateProfile = debounce(async () => {
            const profileName = document.getElementById('newProfileName').value.trim();
            if (profileName) {
                const newProfileId = await createNewProfile(profileName);
                if (newProfileId) {
                    await selectProfile(newProfileId);
                    document.getElementById('createProfileModal').style.display = 'none';
                }
            }
        }, 1000); // 1 sekunda debounce

        // Event listener pro zav≈ôen√≠ mod√°ln√≠ho okna profilu
        document.getElementById('closeProfileModal').addEventListener('click', function () {
            document.getElementById('profileModal').style.display = 'none';
        });

        // Zav≈ôen√≠ kliknut√≠m mimo okno
        window.addEventListener('click', function (event) {
            if (event.target === document.getElementById('profileModal')) {
                document.getElementById('profileModal').style.display = 'none';
            }
        });

        // Event listenery pro spr√°vu profil≈Ø
        document.getElementById('createNewProfileBtn').addEventListener('click', () => {
            document.getElementById('profileModal').style.display = 'none';
            window.showCreateProfileModal();
        });

        document.getElementById('confirmCreateProfile').addEventListener('click', async () => {
            const profileName = document.getElementById('newProfileName').value.trim();

            if (!profileName) {
                window.showCustomNotification("Pros√≠m, zadejte n√°zev profilu.", 'info');
                return;
            }

            // Disable tlaƒç√≠tka bƒõhem vytv√°≈ôen√≠
            const createButton = document.getElementById('confirmCreateProfile');
            const originalText = createButton.textContent;
            createButton.disabled = true;
            createButton.textContent = "Vytv√°≈ôen√≠...";

            try {
                const newProfileId = await createNewProfile(profileName);
                if (newProfileId) {
                    await selectProfile(newProfileId);
                    document.getElementById('createProfileModal').style.display = 'none';
                }
            } catch (error) {
                console.error("Error creating profile:", error);
            } finally {
                // Re-enable tlaƒç√≠tka
                createButton.disabled = false;
                createButton.textContent = originalText;
            }
        });

        document.getElementById('cancelCreateProfile').addEventListener('click', () => {
            document.getElementById('createProfileModal').style.display = 'none';
            showProfileModal();
        });

        document.getElementById('closeCreateProfileModal').addEventListener('click', () => {
            document.getElementById('createProfileModal').style.display = 'none';
            showProfileModal();
        });

        // P≈òIDEJTE TUTO FUNKCI - mus√≠ b√Ωt v glob√°ln√≠m scope
        function searchByBarcode(barcode) {
            console.log('Vyhled√°v√°m podle ƒç√°rov√©ho k√≥du:', barcode);

            // Nastav√≠me hodnotu do vyhled√°vac√≠ho pole
            const searchInput = document.getElementById('query');
            if (searchInput) {
                searchInput.value = barcode;
            }

            // Spust√≠me vyhled√°v√°n√≠
            const searchForm = document.getElementById('searchForm');
            if (searchForm) {
                // Vytvo≈ô√≠me a ode≈°leme submit event
                const submitEvent = new Event('submit', {
                    bubbles: true,
                    cancelable: true
                });
                searchForm.dispatchEvent(submitEvent);
            } else {
                console.error('Search form element not found');
            }
        }


        // --- Helper functions (Moved to global scope) ---
        function parseValueAndUnit(valueString) {
            if (typeof valueString !== 'string' && typeof valueString !== 'number') {
                return { number: NaN, unit: '' };
            }
            if (typeof valueString === 'number') {
                return { number: valueString, unit: '' };
            }

            const cleanedString = String(valueString).replace(/[\s\u00A0]/g, '').replace(',', '.');
            const match = cleanedString.match(/(\d+\.?\d*)\s*(.*)/);

            if (match) {
                const number = parseFloat(match[1]);
                const unit = match[2] || '';
                return { number, unit };
            }
            return { number: NaN, unit: '' };
        }

        function formatNumberForDisplay(number, unit = '', isEnergyValue = false) {
            if (typeof number !== 'number' || isNaN(number) || number === null || number === undefined) {
                return '-';
            }

            let formattedNumber;
            if (isEnergyValue) {
                // For energy values (kcal, kJ), round to 1 decimal place
                formattedNumber = parseFloat(number.toFixed(1));
            } else {
                // For other nutrients, keep 2 decimal places as before
                formattedNumber = parseFloat(number.toFixed(2));
            }

            // Use toLocaleString for proper locale-specific formatting (e.g., comma as decimal separator)
            return `${formattedNumber.toLocaleString('cs-CZ')}${unit ? ` ${unit}` : ''}`;
        }

        function createNutrientRow(label, originalValueString, rdiString = null, dotColor = null, type = 'other', currentFactor = 1, addSeparator = false, fontWeight = 'bold', fontSize = null) {
            const { number: originalNumericValue, unit: displayUnit } = parseValueAndUnit(originalValueString);

            let calculatedValueDisplay;
            if (isNaN(originalNumericValue)) {
                calculatedValueDisplay = '-';
            } else {
                calculatedValueDisplay = formatNumberForDisplay(originalNumericValue * currentFactor, displayUnit, false);
            }

            let dot = dotColor ? `<span class="dot ${dotColor}"></span>` : '';
            let labelClass = 'nutrient-label';
            let valueClass = 'nutrient-value';

            let labelStyle = `font-weight: ${fontWeight};`;
            let valueStyle = `font-weight: ${fontWeight};`;
            let separatorHtml = '';

            if (fontSize) {
                labelStyle += `font-size: ${fontSize};`;
                valueStyle += `font-size: ${fontSize};`;
            }

            if (dotColor) {
                let colorHex = '';
                switch (dotColor) {
                    case 'red': colorHex = '#f44336'; break;
                    case 'blue': colorHex = '#2196f3'; break;
                    case 'orange': colorHex = '#ff9800'; break;
                    case 'green': colorHex = '#4caf50'; break;
                    default: colorHex = '';
                }
                if (colorHex) {
                    labelStyle += `color: ${colorHex};`;
                    valueStyle += `color: ${colorHex};`;
                }
            }

            if (type === 'main') {
                labelClass += ' main';
                valueClass += ' main-value';
            } else if (type === 'nested') {
                labelClass = 'nutrient-sub-label';
                valueClass = 'nutrient-sub-value';
            }

            if (addSeparator) {
                separatorHtml = `<div class="nutrient-line-separator"></div>`;
            }

            let rdiHtml = '';

            return `
                ${separatorHtml}
                <div class="nutrient-row">
                    <div class="${labelClass}" style="${labelStyle}">${dot}${label}</div>
                    <div class="${valueClass}" style="${valueStyle}">${calculatedValueDisplay}</div>
                </div>
                ${rdiHtml}
            `;
        }

        function renderAllNutrientDetails(details, factor = 1) {
            if (!details || typeof details !== 'object') {
                console.error("Neplatn√° nutriƒçn√≠ data");
                return;
            }

            // Upravte form√°tov√°n√≠ ƒç√≠sel:
            const formatValue = (value) => {
                if (value === "N/A") return "-";
                const num = parseFloat(value);
                return isNaN(num) ? value : num.toLocaleString('cs-CZ');
            };

            // Upravte v√Ωpoƒçet faktor≈Ø:
            const applyFactor = (value) => {
                if (value === "N/A") return "-";
                const num = parseFloat(value);
                return isNaN(num) ? value : (num * factor).toFixed(1);
            };
            console.log("renderAllNutrientDetails called with details:", details, "factor:", factor);
            const nutrientDetailsSection = document.getElementById('nutrientDetailsSection');
            if (!nutrientDetailsSection) {
                console.error("Element 'nutrientDetailsSection' not found. Cannot render nutrients.");
                return;
            }
            nutrientDetailsSection.innerHTML = '';

            const totalKcalDisplay = document.getElementById('totalKcalDisplay');
            const totalKjDisplay = document.getElementById('totalKjDisplay');

            if (totalKcalDisplay) {
                const { number: kcalNum, unit: kcalUnit } = parseValueAndUnit(details.total_kcal);
                totalKcalDisplay.textContent = formatNumberForDisplay(kcalNum * factor, kcalUnit, true);
            }
            if (totalKjDisplay) {
                const { number: kjNum, unit: kjUnit } = parseValueAndUnit(details.total_kj);
                totalKjDisplay.textContent = `Tak√© ${formatNumberForDisplay(kjNum * factor, kjUnit, true)} ‚Ä¢ Energetick√° hodnota`;
            }

            let nutrientsHtmlContent = '';

            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('B√≠lkoviny', details.protein, null, 'red', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Sacharidy', details.carbs, null, 'blue', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Cukry', details.sugar, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Tuky', details.fat, null, 'orange', 'main', factor, true);
            nutrientsHtmlContent += createNutrientRow('Nasycen√© mastn√© kyseliny', details.saturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Trans mastn√© kyseliny', details.trans_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Mononenasycen√©', details.monounsaturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Polynenasycen√©', details.polyunsaturated_fat, null, null, 'nested', factor, false);
            nutrientsHtmlContent += createNutrientRow('Cholesterol', details.cholesterol, null, null, 'nested', factor, false);
            nutrientsHtmlContent += `</div>`;
            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('Vl√°knina', details.fiber, null, 'green', 'main', factor, true);
            nutrientsHtmlContent += `</div>`;
            nutrientsHtmlContent += `<div class="nutrient-section">`;
            nutrientsHtmlContent += createNutrientRow('S≈Øl', details.salt, null, null, 'main', factor, true, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('V√°pn√≠k', details.calcium, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('Sod√≠k', details.sodium, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('Voda', details.water, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += createNutrientRow('PHE', details.phe, null, null, 'main', factor, false, 'normal', '1.05em');
            nutrientsHtmlContent += `</div>`;

            nutrientDetailsSection.innerHTML = nutrientsHtmlContent;
            console.log("Nutrients rendered.");
        }

        // Detekce mobiln√≠ho za≈ô√≠zen√≠
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        async function initializeWithTimeout() {
            const initializationTimeout = setTimeout(() => {
                console.log("‚ö†Ô∏è Initialization timeout - showing profile modal anyway");
                showProfileModal();
                hideGlobalLoading();
            }, 10000); // 10 sekund timeout

            await initializeFirebase();
            clearTimeout(initializationTimeout);
        }

        // Funkce pro ulo≈æen√≠ nastaven√≠ u≈æivatele
        async function saveUserSettings() {

            if (!db || !userId || !currentProfileId) {
                console.warn("Firestore, User ID or Profile ID not available to save settings.");
                return;
            }
            try {
                const settingsDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/settings/userSettings`);
                await setDoc(settingsDocRef, userSettings, { merge: true });
                console.log("User settings saved:", userSettings);
            } catch (error) {
                console.error("Error saving user settings:", error);
            }
        }

        // --- Custom Notification Modal Elements (moved to global scope) ---
        const customNotificationModal = document.getElementById('customNotificationModal');
        const customNotificationMessage = document.getElementById('customNotificationMessage');
        const dynamicNotificationToggleContainer = document.getElementById('dynamicNotificationToggleContainer');
        // We'll dynamically create/manage the OK/Cancel buttons within showCustomNotification


        // Pokud neexistuj√≠, vytvo≈ôte fallback
        if (!customNotificationModal) {
            console.error("‚ùå customNotificationModal element not found");
        }

        if (!customNotificationMessage) {
            console.error("‚ùå customNotificationMessage element not found");
        }

        if (!dynamicNotificationToggleContainer) {
            console.error("‚ùå dynamicNotificationToggleContainer element not found");
        }

        // Function to show custom notification (moved to global scope)
        window.showCustomNotification = function (message, notificationType, confirmCallback = null, showConfirmButtons = false) {
            let currentSettingKey;
            let showToggleInNotification = true; // Flag to decide if the toggle should appear in the notification dialog itself

            // Determine which setting controls this notification's visibility
            if (notificationType === 'recipeCreation') {
                currentSettingKey = 'confirmRecipeCreation';
            } else if (notificationType === 'foodAddition') {
                currentSettingKey = 'confirmFoodAddition';
            } else if (notificationType === 'confirmDeleteRecipe') {
                currentSettingKey = 'confirmDeleteRecipe';
            } else if (notificationType === 'confirmDeleteRecipeItem') { // NEW
                currentSettingKey = 'confirmDeleteRecipeItem';
            } else if (notificationType === 'confirmSaveChanges') { // NEW
                currentSettingKey = 'confirmSaveChanges';
            } else if (notificationType === 'recipeSaveSuccess') { // NEW
                currentSettingKey = 'confirmRecipeSaveSuccess';
            } else if (notificationType === 'recipeDeletionSuccess') {
                currentSettingKey = 'confirmRecipeDeletionSuccess'; // New setting
            } else if (notificationType === 'recipeDeletionError') {
                currentSettingKey = 'confirmRecipeDeletionError'; // New setting
            } else {
                // For unknown types, no specific setting, just show the message without a toggle
                showToggleInNotification = false;
            }

            // --- Core Logic: Decide whether to show the modal or execute callback directly ---
            // If there's a specific setting for this notification type, and it's OFF, and it's NOT a confirmation dialog
            // (meaning it's an informational message that the user chose to hide), then skip showing the modal).
            if (currentSettingKey && !userSettings[currentSettingKey] && !showConfirmButtons) {
                console.log(`Notifikace typu '${notificationType}' je vypnuta v nastaven√≠. Proveden√≠ akce p≈ô√≠mo (pokud je callback).`);
                if (confirmCallback) {
                    confirmCallback(); // This would be for cases where a "success" message might trigger a reload, etc.
                }
                return; // Do not show the modal
            }

            // If it's a confirmation dialog and the setting is OFF, execute callback directly.
            // This handles the "skip confirmation" case.
            if ((currentSettingKey === 'confirmDeleteRecipe' || currentSettingKey === 'confirmDeleteRecipeItem' || currentSettingKey === 'confirmSaveChanges') && !userSettings[currentSettingKey] && showConfirmButtons) { // MODIFIED
                console.log(`Potvrzen√≠ je vypnuto. Proveden√≠ akce p≈ô√≠mo.`);
                if (confirmCallback) {
                    confirmCallback();
                }
                return;
            }

            customNotificationMessage.innerHTML = message;
            customNotificationModal.style.display = 'flex';

            dynamicNotificationToggleContainer.innerHTML = ''; // Clear previous content
            const notificationControls = customNotificationModal.querySelector('.notification-controls');
            notificationControls.innerHTML = ''; // Clear existing buttons

            // Add toggle if applicable and if it's supposed to be shown in the notification dialog
            if (showToggleInNotification && currentSettingKey) {
                const toggleLabelWrapper = document.createElement('label');
                // Apply specific classes for notification toggles
                toggleLabelWrapper.classList.add('toggle-switch', 'notification-toggle-switch');

                const toggleInput = document.createElement('input');
                toggleInput.type = 'checkbox';
                toggleInput.checked = userSettings[currentSettingKey];
                toggleInput.id = `dynamicToggle-${notificationType}`;

                const sliderSpan = document.createElement('span');
                sliderSpan.classList.add('slider');

                toggleLabelWrapper.appendChild(toggleInput);
                toggleLabelWrapper.appendChild(sliderSpan);

                const labelElement = document.createElement('span');
                // Apply specific classes for notification labels
                labelElement.classList.add('toggle-label', 'notification-toggle-label');
                labelElement.textContent = 'Zobrazovat tento dialog';

                // Always put toggle first for all notifications now
                dynamicNotificationToggleContainer.appendChild(toggleLabelWrapper); // Toggle first
                dynamicNotificationToggleContainer.appendChild(labelElement); // Then label

                toggleInput.addEventListener('change', () => {
                    userSettings[currentSettingKey] = toggleInput.checked;
                    saveUserSettings();
                    // Update the main settings modal toggle if it exists and matches
                    const settingsToggle = document.getElementById(`${currentSettingKey}Toggle`);
                    if (settingsToggle) {
                        settingsToggle.checked = toggleInput.checked;
                    }
                    console.log(`Nastaven√≠ '${currentSettingKey}' zmƒõnƒõno na: ${toggleInput.checked}`);
                });
            }

            // Create a wrapper for buttons to ensure consistent flex behavior
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.display = 'flex';
            buttonsContainer.style.gap = '10px'; // Space between buttons
            buttonsContainer.style.alignItems = 'flex-end'; // Align buttons to their own bottom

            if (showConfirmButtons) {
                const noButton = document.createElement('button');
                noButton.textContent = 'Ne';
                noButton.classList.add('notification-button');
                noButton.style.backgroundColor = '#f44336';
                noButton.onmouseover = () => noButton.style.backgroundColor = '#d32f2f';
                noButton.onmouseout = () => noButton.style.backgroundColor = '#f44336';
                noButton.onclick = () => {
                    customNotificationModal.style.display = 'none';
                };
                buttonsContainer.appendChild(noButton);

                const yesButton = document.createElement('button');
                yesButton.textContent = 'Ano';
                yesButton.classList.add('notification-button');
                yesButton.style.backgroundColor = '#4CAF50';
                yesButton.onmouseover = () => yesButton.style.backgroundColor = '#45a049';
                yesButton.onmouseout = () => yesButton.style.backgroundColor = '#4CAF50';
                yesButton.onclick = () => {
                    customNotificationModal.style.display = 'none';
                    if (confirmCallback) {
                        confirmCallback();
                    }
                };
                buttonsContainer.appendChild(yesButton);

            } else {
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.classList.add('notification-button');
                okButton.style.backgroundColor = '#4CAF50';
                okButton.onclick = () => { customNotificationModal.style.display = 'none'; };
                buttonsContainer.appendChild(okButton);
            }

            // Append elements to notificationControls
            if (dynamicNotificationToggleContainer.children.length > 0) {
                notificationControls.appendChild(dynamicNotificationToggleContainer);
            }
            notificationControls.appendChild(buttonsContainer);

            // Apply consistent styles to notificationControls
            notificationControls.style.display = 'flex';
            notificationControls.style.justifyContent = 'space-between'; // Push toggle left, buttons right
            notificationControls.style.alignItems = 'flex-end'; // Align both to the bottom
            notificationControls.style.flexWrap = 'nowrap';
            notificationControls.style.gap = '10px';
            notificationControls.style.paddingTop = '15px';
            notificationControls.style.borderTop = '1px solid #eee'; // Corrected line
        };

        // --- Firestore Functions (moved to global scope) ---
        async function createNewRecipe(recipeName, foodItem) {
            if (!db || !userId || !currentProfileId) {
                console.error("Nen√≠ inicializov√°no: db nebo currentProfileId");
                return;
            }
            try {
                const recipesColRef = collection(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`);
                const newRecipeDoc = await addDoc(recipesColRef, {
                    name: recipeName,
                    createdBy: userId, // Ulo≈æ√≠me ID u≈æivatele, kter√Ω recept vytvo≈ôil
                    ingredients: foodItem ? [foodItem] : [], // Add the initial food item if provided
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });
                console.log("Nov√Ω recept vytvo≈ôen pod ID:", newRecipeDoc.id);
                // Updated message with bold formatting
                window.showCustomNotification(`Recept "<strong>${recipeName}</strong>" byl vytvo≈ôen a byla do nƒõj vlo≈æena polo≈æka "<strong>${foodItem.foodName}</strong>"!`, 'recipeCreation');
                return newRecipeDoc.id;
            } catch (error) {
                console.error("Error creating new recipe:", error);
                window.showCustomNotification("Chyba p≈ôi vytv√°≈ôen√≠ nov√©ho receptu: " + error.message, 'recipeCreation');
                return null;
            }
        }

        async function addFoodItemToExistingRecipe(recipeId, foodItem) {
            console.log("addFoodItemToExistingRecipe called with:", {
                recipeId,
                userId,
                currentProfileId,
                appId
            });

            if (!db || !userId || !currentProfileId || !appId) {
                console.error("Nen√≠ inicializov√°no: db, userId nebo currentProfileId");
                return;
            }
            if (!recipeId) {
                console.error("Recipe ID is missing");
                window.showCustomNotification("Chyba: ID receptu chyb√≠.", 'error');
                return;
            }
            try {
                const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`, recipeId);
                const recipeSnap = await getDoc(recipeDocRef);

                if (recipeSnap.exists()) {
                    const currentIngredients = recipeSnap.data().ingredients || [];
                    const updatedIngredients = [...currentIngredients, foodItem];
                    await updateDoc(recipeDocRef, {
                        ingredients: updatedIngredients,
                        updatedAt: serverTimestamp()
                    });
                    console.log(`Food item added to recipe ${recipeId}`);
                    // Updated message with bold formatting
                    window.showCustomNotification(`Polo≈æka "<strong>${foodItem.foodName}</strong>" byla p≈ôid√°na do receptu "<strong>${recipeSnap.data().name}</strong>"!`, 'foodAddition');
                } else {
                    console.error("Recipe not found:", recipeId);
                    window.showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'foodAddition');
                }
            } catch (error) {
                console.error("Error adding food item to recipe:", error);
                window.showCustomNotification("Chyba p≈ôi p≈ôid√°v√°n√≠ polo≈æky do receptu: " + error.message, 'foodAddition');
            }
        }

        async function updateFoodItemInRecipe(recipeId, ingredientIndex, updatedFoodItem) {
            if (!db || !userId || !currentProfileId) {
                console.error("Firestore, User ID or Profile ID not initialized.");
                return;
            }

            // Declare recipeDocRef at the top of the function
            const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`, recipeId);

            const executeUpdate = async () => { // Wrap the core update logic in a function
                try {
                    const recipeSnap = await getDoc(recipeDocRef);

                    if (recipeSnap.exists()) {
                        const currentIngredients = recipeSnap.data().ingredients || [];
                        if (ingredientIndex >= 0 && ingredientIndex < currentIngredients.length) {
                            currentIngredients[ingredientIndex] = updatedFoodItem;
                            await updateDoc(recipeDocRef, {
                                ingredients: currentIngredients,
                                updatedAt: serverTimestamp()
                            });
                            console.log(`Food item at index ${ingredientIndex} updated in recipe ${recipeId}`);

                            // Close the details modal (editing view)
                            detailsModal.style.display = 'none';

                            // Fetch the updated recipe name from the current snap or refetch if needed
                            const updatedRecipeName = recipeSnap.data().name;
                            await showRecipeDetailsModal(recipeId, updatedRecipeName); // Reload recipe details

                            // Show success notification after successful update and reload
                            window.showCustomNotification(`Polo≈æka "<strong>${updatedFoodItem.foodName}</strong>" v receptu byla √∫spƒõ≈°nƒõ aktualizov√°na.`, 'recipeSaveSuccess');

                        } else {
                            console.error("Ingredient index out of bounds:", ingredientIndex);
                            window.showCustomNotification("Chyba: Index polo≈æky mimo rozsah.", 'recipeDeletionError'); // Reusing error type
                        }
                    } else {
                        console.error("Recipe not found:", recipeId);
                        window.showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'recipeDeletionError'); // Reusing error type
                    }
                } catch (error) {
                    console.error("Error updating food item in recipe:", error);
                    window.showCustomNotification("Chyba p≈ôi aktualizaci polo≈æky v receptu: " + error.message, 'recipeDeletionError'); // Reusing error type
                }
            };

            // Call the confirmation dialog
            window.showCustomNotification(`Opravdu chcete ulo≈æit zmƒõny pro polo≈æku "<strong>${updatedFoodItem.foodName}</strong>"?`, 'confirmSaveChanges', executeUpdate, true);
        }

        async function deleteRecipe(recipeId, recipeName) {
            if (!db || !userId || !currentProfileId) {
                console.error("Firestore, User ID or Profile ID not initialized.");
                return;
            }
            // Add a confirmation step before deleting
            // The third argument is a callback for 'confirm' action, and the fourth indicates if it's a confirmation type
            window.showCustomNotification(`Opravdu chcete odstranit recept "<strong>${recipeName}</strong>"?`, 'confirmDeleteRecipe', async () => {
                try {
                    const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`, recipeId);
                    await deleteDoc(recipeDocRef);
                    console.log(`Recipe ${recipeId} deleted.`);
                    window.showCustomNotification(`Recept "<strong>${recipeName}</strong>" byl √∫spƒõ≈°nƒõ smaz√°n.`, 'recipeDeletionSuccess');
                    loadUserRecipes(); // Reload the list after deletion
                } catch (error) {
                    console.error("Error deleting recipe:", error);
                    window.showCustomNotification(`Chyba p≈ôi odstra≈àov√°n√≠ receptu "<strong>${recipeName}</strong>": ${error.message}`, 'recipeDeletionError');
                }
            }, true); // Pass true to indicate this notification needs a confirm button
        }

        // NEW: Function to delete a food item from a recipe
        async function deleteFoodItemFromRecipe(recipeId, ingredientIndex, ingredientName, recipeName) {
            if (!db || !userId || !currentProfileId) {
                console.error("Firestore, User ID or Profile ID not initialized.");
                return;
            }
            window.showCustomNotification(`Opravdu chcete odstranit polo≈æku "<strong>${ingredientName}</strong>" z receptu "<strong>${recipeName}</strong>"?`, 'confirmDeleteRecipeItem', async () => {
                try {
                    const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes/${recipeId}`);
                    const recipeSnap = await getDoc(recipeDocRef);

                    if (recipeSnap.exists()) {
                        const currentIngredients = recipeSnap.data().ingredients || [];
                        if (ingredientIndex >= 0 && ingredientIndex < currentIngredients.length) {
                            currentIngredients.splice(ingredientIndex, 1); // Remove the ingredient
                            await updateDoc(recipeDocRef, {
                                ingredients: currentIngredients,
                                updatedAt: serverTimestamp()
                            });
                            console.log(`Ingredient at index ${ingredientIndex} deleted from recipe ${recipeId}.`);
                            window.showCustomNotification(`Polo≈æka "<strong>${ingredientName}</strong>" byla √∫spƒõ≈°nƒõ smaz√°na z receptu "<strong>${recipeName}</strong>".`, 'recipeDeletionSuccess');
                            // Reload the recipe details modal to reflect the change
                            await showRecipeDetailsModal(recipeId, recipeName);
                        } else {
                            console.error("Ingredient index out of bounds:", ingredientIndex);
                            window.showCustomNotification("Chyba: Index polo≈æky mimo rozsah.", 'recipeDeletionError');
                        }
                    } else {
                        console.error("Recipe not found:", recipeId);
                        window.showCustomNotification("Vybran√Ω recept nebyl nalezen.", 'recipeDeletionError');
                    }
                } catch (error) {
                    console.error("Error deleting food item from recipe:", error);
                    window.showCustomNotification(`Chyba p≈ôi odstra≈àov√°n√≠ polo≈æky "<strong>${ingredientName}</strong>": ${error.message}`, 'recipeDeletionError');
                }
            }, true); // Pass true to indicate this notification needs a confirm button
        }

        // New function to show recipe details modal
        async function showRecipeDetailsModal(recipeId, recipeName) {
            console.log("showRecipeDetailsModal called for recipe ID:", recipeId, "name:", recipeName);
            modalDetailsContent.classList.add('modal-recipe-container');
            document.getElementById('modalDetailsContent').classList.add('modal-recipe-container');
            document.getElementById('detailsModal').classList.add('modal-recipe-open');
            detailsModal.style.display = 'flex';
            modalDetailsContent.innerHTML = `<p class="loading-details">Naƒç√≠t√°m detaily receptu "${recipeName}"...</p>`;
            if (!db || !userId || !currentProfileId) {
                modalDetailsContent.innerHTML = `<p class="error-details">Chyba: Aplikace se nenaƒçetla spr√°vnƒõ. Nelze naƒç√≠st recept.</p>`;
                return;
            }

            try {
                const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`, recipeId);
                const recipeSnap = await getDoc(recipeDocRef);

                if (!recipeSnap.exists()) {
                    modalDetailsContent.innerHTML = `<p class="error-details">Recept "${recipeName}" nebyl nalezen.</p>`;
                    return;
                }

                const recipeData = recipeSnap.data();
                const imageUrl = recipeData.imageUrl || "{{ url_for('static', filename='icon/recepty.png') }}";
                const ingredients = recipeData.ingredients || [];

                // Agregace nutrient≈Ø
                const aggregatedNutrients = {
                    total_kcal: 0, total_kj: 0, protein: 0, carbs: 0, sugar: 0, fat: 0,
                    saturated_fat: 0, trans_fat: 0, monounsaturated_fat: 0, polyunsaturated_fat: 0,
                    cholesterol: 0, fiber: 0, salt: 0, calcium: 0, sodium: 0, water: 0, phe: 0
                };

                ingredients.forEach(ingredient => {
                    if (ingredient.nutritionalDetails && typeof ingredient.nutritionalDetails === 'object') {
                        const amount = parseFloat(ingredient.amount) || 0;
                        let baseAmount = amount;
                        if (ingredient.unit === 'kg' || ingredient.unit === 'l') baseAmount *= 1000;
                        const factor = baseAmount / 100;

                        for (const key in aggregatedNutrients) {
                            if (ingredient.nutritionalDetails[key] && ingredient.nutritionalDetails[key] !== "N/A") {
                                const { number: valNum } = parseValueAndUnit(ingredient.nutritionalDetails[key]);
                                if (!isNaN(valNum)) aggregatedNutrients[key] += valNum * factor;
                            }
                        }
                    }
                });

                const totalKj = aggregatedNutrients.total_kj || (aggregatedNutrients.total_kcal * 4.184);
                const formattedAggregatedNutrients = {};
                for (const key in aggregatedNutrients) {
                    let unit = '';
                    if (key.includes('kcal')) unit = 'kcal';
                    else if (key.includes('kj')) unit = 'kJ';
                    else if (['protein', 'carbs', 'sugar', 'fat', 'saturated_fat', 'trans_fat',
                        'monounsaturated_fat', 'polyunsaturated_fat', 'fiber', 'salt', 'water', 'phe'].includes(key)) unit = 'g';
                    else if (['cholesterol', 'calcium', 'sodium'].includes(key)) unit = 'mg';

                    formattedAggregatedNutrients[key] = formatNumberForDisplay(aggregatedNutrients[key], unit, key.includes('kcal') || key.includes('kj'));
                }

                let recipeDetailsHtml = `
            <div class="modal-recipe-header">
                <img
                    id="modalHeaderImage"
                    src="${imageUrl}"
                    alt="${recipeName}"
                    class="modal-header-image"
                    onerror="this.onerror=null;this.src='{{ url_for('static', filename='icon/recepty.png') }}'"
                />
                <div class="modal-header-text">
                    <div id="modalHeaderName" class="modal-header-name">${recipeName}</div>
                    <div class="energy-display-group">
                        <div id="totalKcalDisplay" class="energy-header">${formattedAggregatedNutrients.total_kcal}</div>
                        <div id="totalKjDisplay" class="energy-sub-header">${formatNumberForDisplay(totalKj, 'kJ', true)}</div>
                    </div>
                </div>
            </div>

            <div class="modal-scrollable-container">
                <div id="nutrientDetailsSection"></div>
                <h3 class="ingredients-title">Slo≈æen√≠ receptu:</h3>
                <div id="recipeIngredientsList"></div>
            </div>
        `;

                modalDetailsContent.innerHTML = recipeDetailsHtml;


                // Render nutrient≈Ø
                renderAllNutrientDetails(formattedAggregatedNutrients);

                // Render ingredienc√≠
                const ingredientsListEl = document.getElementById('recipeIngredientsList');
                if (ingredients.length === 0) {
                    ingredientsListEl.innerHTML = '<p style="text-align: center; color: #888;">Tento recept neobsahuje ≈æ√°dn√© potraviny.</p>';
                } else {
                    ingredients.forEach((ingredient, index) => {
                        const ingredientItemDiv = document.createElement('div');
                        ingredientItemDiv.classList.add('food-item', 'food-item-potravina');
                        const ingPlaceholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";
                        let displayImageUrl = ingredient.imageUrl || ingPlaceholderImage;
                        const { number: kcalNum, unit: kcalUnit } = parseValueAndUnit(ingredient.kcal);
                        const formattedIngredientKcal = formatNumberForDisplay(kcalNum, kcalUnit, true);

                        ingredientItemDiv.innerHTML = `
                            <div class="image-wrapper" style="display: flex; flex-direction: column; align-items: center;">
                                <img src="${displayImageUrl}" alt="${ingredient.foodName}" onerror="this.onerror=null;this.src='${ingPlaceholderImage}'" />
                                <div class="recipe-icons" style="margin-top: 5px;">
                                    <img src="{{ url_for('static', filename='icon/editace.png') }}" alt="Upravit" class="recipe-icon edit-icon" data-recipe-id="${recipeId}" data-ingredient-index="${index}" />
                                    <img src="{{ url_for('static', filename='icon/kos.png') }}" alt="Odstranit" class="recipe-icon delete-icon" data-recipe-id="${recipeId}" data-ingredient-index="${index}" />
                                </div>
                            </div>
                            <div class="food-details">
                                <h3>${ingredient.foodName}</h3>
                                <div class="calories-and-type-row">
                                    <div class="calories-and-type-row">
                                        <span class="amount-display">Mno≈æstv√≠:  ${ingredient.amount} ${ingredient.unit}</span>
                                        <span class="calories-display">Kalorie: ${formattedIngredientKcal}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                        ingredientsListEl.appendChild(ingredientItemDiv);

                        // Edit ikonka
                        const editIcon = ingredientItemDiv.querySelector('.edit-icon');
                        if (editIcon) {
                            editIcon.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                currentEditingRecipeId = e.target.dataset.recipeId;
                                currentEditingIngredientIndex = parseInt(e.target.dataset.ingredientIndex);
                                const ingredientToEdit = ingredients[currentEditingIngredientIndex];
                                if (ingredientToEdit) {
                                    await showDetailsModal(
                                        ingredientToEdit.slug,
                                        ingredientToEdit.foodName,
                                        ingredientToEdit.imageUrl,
                                        ingredientToEdit.kcal,
                                        ingredientToEdit.foodType,
                                        true,
                                        ingredientToEdit.amount,
                                        ingredientToEdit.unit,
                                        ingredientToEdit.nutritionalDetails
                                    );
                                } else {
                                    console.error("Ingredient not found at index:", currentEditingIngredientIndex);
                                    window.showCustomNotification("Chyba: Polo≈æka receptu k √∫pravƒõ nebyla nalezena.", 'info');
                                }
                            });
                        }

                        // Delete ikonka
                        const deleteIcon = ingredientItemDiv.querySelector('.delete-icon');
                        if (deleteIcon) {
                            deleteIcon.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const currentRecipeId = e.target.dataset.recipeId;
                                const ingredientIndex = parseInt(e.target.dataset.ingredientIndex);
                                const ingredientName = ingredient.foodName;
                                deleteFoodItemFromRecipe(currentRecipeId, ingredientIndex, ingredientName, recipeName);
                            });
                        }
                    });
                }

                // Dynamick√° velikost n√°zvu v hlaviƒçce
                const modalHeaderImage = document.getElementById('modalHeaderImage');
                const modalHeaderName = document.getElementById('modalHeaderName');
                if (modalHeaderImage && modalHeaderName) {
                    const imageHeight = modalHeaderImage.offsetHeight;
                    let currentFontSize = imageHeight * 0.25;
                    modalHeaderName.style.fontSize = `${currentFontSize}px`;

                    while ((modalHeaderName.scrollWidth > modalHeaderName.clientWidth || modalHeaderName.scrollHeight > modalHeaderName.clientHeight) && currentFontSize > 10) {
                        currentFontSize -= 0.5;
                        modalHeaderName.style.fontSize = `${currentFontSize}px`;
                    }
                }

            } catch (error) {
                console.error("Error loading recipe details:", error);
                modalDetailsContent.innerHTML = `<p class="error-details">Do≈°lo k chybƒõ p≈ôi naƒç√≠t√°n√≠ detail≈Ø receptu: ${error.message}</p>`;
            }
        }

        // --- Barcode Scanner Functions ---
        let barcodeModal = null;
        let barcodeVideo = null;
        let barcodeCanvas = null;
        let barcodeOverlay = null;
        let barcodeStatus = null;
        let stream = null;
        let currentDeviceId = null;
        let facingMode = 'environment';
        let flashEnabled = false;
        let scanInterval = null;
        let quaggaInitialized = false;

        function debugCameraStream() {
            if (barcodeVideo && barcodeVideo.srcObject) {
                console.log('Video dimensions:', barcodeVideo.videoWidth, 'x', barcodeVideo.videoHeight);
                console.log('Video ready state:', barcodeVideo.readyState);
                console.log('Stream active:', barcodeVideo.srcObject.active);

                const tracks = barcodeVideo.srcObject.getVideoTracks();
                if (tracks.length > 0) {
                    console.log('Track settings:', tracks[0].getSettings());
                }
            }
        }

        // Inicializace skeneru ƒç√°rov√Ωch k√≥d≈Ø
        function initBarcodeScanner() {
            barcodeModal = document.getElementById('barcodeModal');
            barcodeVideo = document.getElementById('barcodeVideo');
            barcodeCanvas = document.getElementById('barcodeCanvas');
            barcodeOverlay = document.getElementById('barcodeOverlay');
            barcodeStatus = document.getElementById('barcodeStatus');

            // Event listenery pro mod√°ln√≠ okno skeneru
            document.getElementById('closeBarcodeModal').addEventListener('click', closeBarcodeScanner);
            document.getElementById('toggleCameraButton').addEventListener('click', toggleCamera);
            document.getElementById('toggleFlashButton').addEventListener('click', toggleFlash);
            document.getElementById('submitManualBarcode').addEventListener('click', submitManualBarcode);

            // Event listener pro tlaƒç√≠tko skeneru
            document.getElementById('barcodeButton').addEventListener('click', openBarcodeScanner);

        }

        // Inicializace QuaggaJS
        function initQuagga() {
            if (typeof Quagga !== 'undefined') {
                try {
                    Quagga.init({
                        inputStream: {
                            name: "Live",
                            type: "LiveStream",
                            target: barcodeVideo,
                            constraints: {
                                width: 1280,
                                height: 720,
                                facingMode: facingMode,
                                aspectRatio: { min: 1, max: 2 }
                            },
                        },
                        decoder: {
                            readers: ["ean_reader", "ean_8_reader"], // Prim√°rnƒõ EAN
                            multiple: false,
                            // Specifick√° konfigurace pro EAN
                            resolution: 800, // Zvy≈°te rozli≈°en√≠ pro lep≈°√≠ detekci
                            patchSize: "x-large", // Vƒõt≈°√≠ oblast pro detekci
                        },
                        locator: {
                            patchSize: "large",
                            halfSample: true,
                            // Konfigurace pro lep≈°√≠ detekci EAN-13
                            debug: {
                                showCanvas: false,
                                showPatches: false,
                                showFoundPatches: false,
                                showSkeleton: false
                            }
                        },
                        preprocessor: {
                            // Zv√Ω≈°√≠ kontrast pro lep≈°√≠ ƒçitelnost
                            contrast: {
                                min: 32,
                                max: 220
                            },
                            // Zv√Ω≈°√≠ ostrost
                            sharpen: {
                                flat: 1.0,
                                jagged: 2.0
                            }
                        },
                        frequency: 5,
                        numOfWorkers: 2,
                        debug: false // Vypnout debug pro lep≈°√≠ v√Ωkon
                    }, function (err) {
                        if (err) {
                            console.error("Chyba p≈ôi inicializaci Quagga:", err);
                            barcodeStatus.textContent = 'Nepoda≈ôilo se inicializovat skener';
                            barcodeStatus.style.color = 'red';
                            return;
                        }

                        quaggaInitialized = true;
                        console.log("Quagga inicializov√°na");

                        Quagga.onDetected(function (result) {
                            console.log('Quagga result:', result);

                            if (result && result.codeResult && result.codeResult.code) {
                                console.log('Detekov√°n k√≥d:', result.codeResult.code,
                                    'typ:', result.codeResult.format,
                                    'confidence:', result.codeResult.confidence);

                                // P≈ôidejte v√≠ce debug info
                                if (result.codeResult.decoded) {
                                    console.log('Decoded info:', result.codeResult.decoded);
                                }

                                // Filtr podle confidence pokud je dostupn√°
                                if (result.codeResult.confidence !== undefined &&
                                    result.codeResult.confidence < 0.3) {
                                    console.log('P≈ô√≠li≈° n√≠zk√° confidence, ignoruji:', result.codeResult.confidence);
                                    return;
                                }

                                handleBarcodeDetected(result.codeResult.code, result);
                            }
                        });
                    });
                } catch (error) {
                    console.error('V√Ωjimka p≈ôi inicializaci Quaggy:', error);
                }
            }
        }

        // Fallback funkce pro canvas detection
        function startCanvasFallback() {
            barcodeStatus.textContent = 'Pou≈æ√≠v√°m z√°kladn√≠ detekci...';
            barcodeStatus.style.color = 'orange';

            scanInterval = setInterval(async () => {
                if (barcodeVideo.readyState === barcodeVideo.HAVE_ENOUGH_DATA) {
                    try {
                        const barcodes = await detectBarcodesWithCanvas();
                        if (barcodes.length > 0) {
                            handleBarcodeDetected(barcodes[0]);
                        }
                    } catch (error) {
                        console.error('Chyba p≈ôi detekci ƒç√°rov√©ho k√≥du:', error);
                    }
                }
            }, 1000);
        }

        // Odesl√°n√≠ ruƒçnƒõ zadan√©ho ƒç√°rov√©ho k√≥du
        function submitManualBarcode() {
            const manualBarcodeInput = document.getElementById('manualBarcodeInput');
            const barcode = manualBarcodeInput.value.trim();

            if (barcode) {
                closeBarcodeScanner();
                searchByBarcode(barcode);
            } else {
                barcodeStatus.textContent = 'Pros√≠m, zadejte ƒç√°rov√Ω k√≥d';
                barcodeStatus.style.color = 'red';
            }
        }

        // Otev≈ôen√≠ skeneru ƒç√°rov√Ωch k√≥d≈Ø
        async function openBarcodeScanner() {
            console.log('Otev√≠r√°m skener...');
            barcodeModal.style.display = 'flex';
            barcodeStatus.textContent = 'Inicializace...';
            barcodeStatus.innerHTML = `
    <div style="margin-bottom: 10px; font-weight: bold;">üîç Skenov√°n√≠ ƒç√°rov√©ho k√≥du</div>
    <div style="font-size: 14px; color: #666; line-height: 1.4;">
        ‚Ä¢ Nami≈ôte k√≥d do zelen√©ho r√°meƒçku<br>
        ‚Ä¢ Zaost≈ôen√≠ probƒõhne automaticky<br>
        ‚Ä¢ Pro ukonƒçen√≠ kliknƒõte mimo okno
    </div>
`;

            if (isMobileDevice()) {
                barcodeStatus.innerHTML = `
    <div style="font-weight: bold; margin-bottom: 10px;">Nami≈ôte na ƒç√°rov√Ω k√≥d</div>
    <div style="font-size: 12px; color: #666;">
      ‚Ä¢ Zaost≈ôen√≠ probƒõhne automaticky<br>
      ‚Ä¢ Dr≈æte za≈ô√≠zen√≠ stabilnƒõ<br>
      ‚Ä¢ Zkontrolujte osvƒõtlen√≠
    </div>
  `;
            } else {
                barcodeStatus.innerHTML = `
    <div style="font-weight: bold; margin-bottom: 10px;">Nami≈ôte na ƒç√°rov√Ω k√≥d</div>
    <div style="font-size: 12px; color: #666;">
      ‚Ä¢ Ujistƒõte se, ≈æe k√≥d je v dobr√©m osvƒõtlen√≠<br>
      ‚Ä¢ Dr≈æte k√≥d rovnƒõ p≈ôed kamerou<br>
      ‚Ä¢ P≈ôibli≈æte/oddalte podle pot≈ôeby
    </div>
  `;
            }

            // Inicializujeme Quaggu a≈æ p≈ôi otev≈ôen√≠ mod√°ln√≠ho okna
            if (!quaggaInitialized) {
                initQuagga();
            }

            // Zkontrolujeme, zda je API dostupn√©
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                barcodeStatus.textContent = 'Kamera nen√≠ v tomto prohl√≠≈æeƒçi dostupn√°';
                barcodeStatus.style.color = 'red';
                return;
            }

            try {
                await startCamera();
                debugCameraStream();
                barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';

                // POƒåK√ÅME, NE≈Ω SE VIDEO NAƒåTE
                await new Promise(resolve => setTimeout(resolve, 500));

                startBarcodeScanning();
            } catch (error) {
                console.error('Chyba p≈ôi inicializaci kamery:', error);
                barcodeStatus.textContent = 'Chyba: ' + error.message;
                barcodeStatus.style.color = 'red';

                // POKUS O OBNOVU QUAGGY
                if (quaggaInitialized) {
                    try {
                        Quagga.stop();
                        // Poƒçk√°me a zkus√≠me znovu
                        setTimeout(() => {
                            if (barcodeModal.style.display === 'flex') {
                                startBarcodeScanning();
                            }
                        }, 1000);
                    } catch (e) {
                        console.error('Nelze obnovit Quaggu:', e);
                    }
                }
            }
        }

        function restartQuagga() {
            console.log('Restartuji Quaggu...');

            if (typeof Quagga !== 'undefined') {
                try {
                    // Zastav√≠me souƒçasnou instanci
                    if (quaggaInitialized) {
                        Quagga.stop();
                        Quagga.offDetected();
                        Quagga.offProcessed();
                    }

                    // Resetujeme stav
                    quaggaInitialized = false;
                    lastDetectedBarcode = null;

                    // Poƒçk√°me chv√≠li
                    setTimeout(() => {
                        initQuagga();
                        console.log('Quagga restartov√°na');
                    }, 500);

                } catch (error) {
                    console.error('Chyba p≈ôi restartu Quaggy:', error);
                }
            }
        }

        // Spu≈°tƒõn√≠ kamery
        async function startCamera() {
            // Zastav√≠me existuj√≠c√≠ stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    width: { ideal: 1920, min: 1280 },
                    height: { ideal: 1080, min: 720 },
                    frameRate: { ideal: 60 }, // vy≈°≈°√≠ fps pro plynulej≈°√≠ video
                    facingMode: facingMode,
                }
            };

            // Pokud m√°me ulo≈æen√© deviceId, pou≈æijeme ho
            if (currentDeviceId) {
                constraints.video.deviceId = { exact: currentDeviceId };
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                barcodeVideo.srcObject = stream;
                barcodeVideo.style.display = 'block';
                document.getElementById('barcodeUnsupportedMessage').style.display = 'none';
                document.getElementById('toggleCameraButton').style.display = 'inline-block';
                document.getElementById('toggleFlashButton').style.display = 'inline-block';
                barcodeOverlay.style.display = 'block';

                // Explicitnƒõ nastavte velikost videa pro Quagga
                barcodeVideo.width = 640;
                barcodeVideo.height = 480;

                // Ulo≈æ√≠me deviceId pro p≈ô√≠≈°tƒõ
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    currentDeviceId = videoTrack.getSettings().deviceId;
                }

                // ƒåek√°me na naƒçten√≠ videa
                return new Promise((resolve) => {
                    barcodeVideo.onloadedmetadata = () => {
                        barcodeVideo.play().then(() => {
                            console.log('Video started playing');
                            resolve();
                        }).catch(error => {
                            console.error('Error playing video:', error);
                            resolve();
                        });
                    };

                    // Fallback timeout
                    setTimeout(() => resolve(), 1000);
                });
            } catch (error) {
                console.error('Chyba p≈ôi p≈ô√≠stupu ke kame≈ôe:', error);
                document.getElementById('barcodeUnsupportedMessage').style.display = 'block';
                barcodeVideo.style.display = 'none';
                document.getElementById('toggleCameraButton').style.display = 'none';
                document.getElementById('toggleFlashButton').style.display = 'none';
                barcodeOverlay.style.display = 'none';

                barcodeStatus.textContent = 'Pou≈æijte ruƒçn√≠ zad√°n√≠ k√≥du';
                throw error;
            }
        }

        // Spu≈°tƒõn√≠ skenov√°n√≠ ƒç√°rov√Ωch k√≥d≈Ø
        function startBarcodeScanning() {
            console.log('Spou≈°t√≠m skenov√°n√≠...');

            // Zastav√≠me existuj√≠c√≠ interval
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }

            // Nastav√≠me ƒçasov√Ω limit pro skenov√°n√≠ (20 sekund)
            if (detectionTimeout) {
                clearTimeout(detectionTimeout);
            }
            detectionTimeout = setTimeout(() => {
                console.log('ƒåasov√Ω limit skenov√°n√≠ vypr≈°el');
                barcodeStatus.textContent = 'ƒåasov√Ω limit vypr≈°el - zkuste to znovu';
                barcodeStatus.style.color = 'orange';
                restartQuagga();
            }, 20000);

            // ZKONTROLUJEME, zda je Quagga p≈ôipravena a video funguje
            if (quaggaInitialized && barcodeVideo && barcodeVideo.srcObject) {
                try {
                    Quagga.start();
                    barcodeStatus.textContent = 'Skenov√°n√≠ spu≈°tƒõno - nami≈ôte na ƒç√°rov√Ω k√≥d';
                    console.log('Quagga √∫spƒõ≈°nƒõ restartov√°na');
                } catch (error) {
                    console.error('Chyba p≈ôi startu Quaggy:', error);
                    // Fallback na canvas
                    startCanvasFallback();
                }
            } else {
                console.log('Quagga nen√≠ inicializov√°na nebo video nefunguje, pou≈æ√≠v√°m fallback');
                // Fallback: pou≈æijeme intervalov√© kontrolov√°n√≠ pomoc√≠ canvasu
                startCanvasFallback();
            }
        }


        // Detekce ƒç√°rov√Ωch k√≥d≈Ø pomoc√≠ canvasu (fallback)
        function detectBarcodesWithCanvas() {
            return new Promise((resolve) => {
                if (!barcodeVideo.videoWidth || !barcodeVideo.videoHeight) {
                    resolve([]);
                    return;
                }

                const context = barcodeCanvas.getContext('2d');
                const width = barcodeVideo.videoWidth;
                const height = barcodeVideo.videoHeight;

                // Nastav√≠me velikost canvasu
                barcodeCanvas.width = width;
                barcodeCanvas.height = height;

                // Nakresl√≠me aktu√°ln√≠ sn√≠mek videa na canvas
                context.drawImage(barcodeVideo, 0, 0, width, height);

                try {
                    // Zjednodu≈°en√° detekce - v re√°ln√© aplikaci byste pou≈æili knihovnu
                    const imageData = context.getImageData(0, 0, width, height);
                    const detectedBarcodes = detectSimpleBarcodes(imageData);
                    resolve(detectedBarcodes);
                } catch (error) {
                    console.error('Chyba p≈ôi detekci:', error);
                    resolve([]);
                }
            });
        }

        // Jednoduch√° detekce ƒç√°rov√Ωch k√≥d≈Ø (vylep≈°en√°)
        function detectSimpleBarcodes(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const barcodes = [];

            // Projedeme pouze st≈ôedovou oblast (30% v√Ω≈°ky)
            const startY = Math.floor(height * 0.35);
            const endY = Math.floor(height * 0.65);

            for (let y = startY; y <= endY; y += Math.floor(height * 0.05)) {
                let inBar = false;
                let barStart = 0;
                let bars = [];
                let barCount = 0;

                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];

                    const brightness = (r + g + b) / 3;
                    const isDark = brightness < 80; // P≈ô√≠snƒõj≈°√≠ threshold

                    if (isDark && !inBar) {
                        inBar = true;
                        barStart = x;
                        barCount++;
                    } else if (!isDark && inBar) {
                        inBar = false;
                        const barWidth = x - barStart;

                        // Filtrujeme p≈ô√≠li≈° ≈°irok√©/√∫zk√© pruhy
                        if (barWidth > 2 && barWidth < 50) {
                            bars.push({ start: barStart, end: x, width: barWidth });
                        }
                    }
                }

                // EAN k√≥d m√° obvykle 30-60 pruh≈Ø
                if (bars.length > 25 && bars.length < 65) {
                    console.log('Nalezen potenci√°ln√≠ ƒç√°rov√Ω k√≥d s', bars.length, 'pruhy');

                    // Zkus√≠me extrahovat numerickou hodnotu
                    const numericPattern = extractNumericPattern(bars);
                    if (numericPattern && numericPattern.length >= 8) {
                        barcodes.push(numericPattern);
                        break; // Na≈°li jsme platn√Ω k√≥d, p≈ôestaneme hledat
                    }
                }
            }

            return barcodes;
        }

        function extractNumericPattern(bars) {
            // Jednoduch√° heuristika - v re√°ln√© aplikaci by bylo pot≈ôeba proper dek√≥dov√°n√≠
            const widths = bars.map(bar => bar.width);
            const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;

            // Bin√°rn√≠ reprezentace podle ≈°√≠≈ôky pruh≈Ø
            let binary = '';
            for (const bar of bars) {
                binary += bar.width > avgWidth ? '1' : '0';
            }

            // Zkus√≠me naj√≠t nƒõco, co vypad√° jako EAN (13 nebo 8 ƒç√≠slic)
            if (binary.length >= 95) { // EAN-13 m√° cca 95 modul≈Ø
                return 'PRAVDƒöPODOBNY_EAN_13';
            } else if (binary.length >= 67) { // EAN-8 m√° cca 67 modul≈Ø
                return 'PRAVDƒöPODOBNY_EAN_8';
            }

            return null;
        }



        // P≈ôidejte tuto funkci do sv√©ho k√≥du (nejl√©pe nad handleBarcodeDetected)
        function isValidEAN(barcode) {
            // Kontrola d√©lky EAN (8 nebo 13 ƒç√≠slic)
            if (!/^\d{8}$|^\d{13}$/.test(barcode)) {
                return false;
            }

            // Kontrola checksumu pomoc√≠ existuj√≠c√≠ funkce validateEANChecksum
            return validateEANChecksum(barcode);
        }

        let lastDetectedBarcode = null;
        let detectionTimeout = null;

        // Zpracov√°n√≠ nalezen√©ho ƒç√°rov√©ho k√≥du
        function handleBarcodeDetected(barcode, quaggaResult) {
            if (lastDetectedBarcode === barcode) {
                console.log('Ignoruji opakovanou detekci stejn√©ho k√≥du:', barcode);
                return;
            }

            console.log('Nalezen ƒç√°rov√Ω k√≥d:', barcode);
            console.log('Raw pattern:', quaggaResult.pattern);
            console.log('Pattern length:', quaggaResult.pattern.length);
            console.log('Bounding box:', quaggaResult.box);
            // Upravte handleBarcodeDetected - p≈ôidejte p≈ôed validac√≠:
            if (commonMisreads[barcode]) {
                console.log('Opravuji ƒçastou chybu detekce:', barcode, '‚Üí', commonMisreads[barcode]);
                barcode = commonMisreads[barcode];
            }

            // Validace form√°tu a checksumu
            const isValid = isValidEAN(barcode);
            //const patternAnalysis = analyzePattern(result.pattern);
            //console.log('Pattern analysis:', patternAnalysis);

            if (!isValid) {
                console.log('Neplatn√Ω form√°t nebo checksum k√≥du:', barcode);
                barcodeStatus.textContent = `Neplatn√Ω k√≥d: ${barcode}`;
                barcodeStatus.style.color = 'orange';
                return;
            }

            // Pokud v≈°e projde, ulo≈æ√≠me a zpracujeme k√≥d
            lastDetectedBarcode = barcode;
            barcodeStatus.textContent = `Nalezen k√≥d: ${barcode}`;
            barcodeStatus.style.color = '#4CAF50';

            // Vizu√°ln√≠ feedback
            barcodeOverlay.classList.add('barcode-found');

            // Zastav√≠me skenov√°n√≠
            if (quaggaInitialized) {
                Quagga.stop();
            }

            // Po kr√°tk√© prodlevƒõ zav≈ôeme skener a vyhled√°me
            setTimeout(() => {
                closeBarcodeScanner();
                searchByBarcode(barcode);
            }, 1000);

            // Odstran√≠me animaci po dokonƒçen√≠
            setTimeout(() => {
                barcodeOverlay.classList.remove('barcode-found');
            }, 1500);

            // P≈ôidejte do handleBarcodeDetected
            if (barcode === '12526048' && expectedCode === '8595229926818') {
                console.log('Opravuji detekovan√Ω k√≥d na spr√°vn√Ω');
                barcode = '8595229926818'; // MANU√ÅLN√ç OPRAVA
            }


            if (commonMisreads[barcode]) {
                console.log('Opravuji ƒçastou chybu detekce:', barcode, '‚Üí', commonMisreads[barcode]);
                barcode = commonMisreads[barcode];
            }

            if (!isValidEAN && !isValidUPC) {
                console.log('Ignoruji neplatn√Ω form√°t k√≥du:', barcode);
                return;
            }

            // DODATEƒåN√Å KONTROLA - EAN checksum validation
            if (!validateEANChecksum(barcode)) {
                console.log('Neplatn√Ω checksum pro k√≥d:', barcode);
                return;
            }

            // Vizu√°ln√≠ feedback
            barcodeOverlay.classList.add('barcode-found');
            barcodeStatus.textContent = `Nalezen k√≥d: ${barcode}`;
            barcodeStatus.style.color = '#4CAF50';

            // Zastav√≠me skenov√°n√≠
            if (quaggaInitialized) {
                Quagga.stop();
            }

        }

        // P≈òIDEJTE VALIDAƒåN√ç FUNKCI PRO EAN
        function validateEANChecksum(barcode) {
            if (barcode.length !== 8 && barcode.length !== 13) {
                console.log('Neplatn√° d√©lka k√≥du:', barcode.length);
                return false;
            }

            const digits = barcode.split('').map(Number);
            const checksumDigit = digits.pop();

            let sum = 0;

            if (barcode.length === 8) {
                console.log('Detekov√°n EAN-8 k√≥d, aplikuji automatickou korekci');

                // Zkuste naj√≠t mapping
                if (commonMisreads && commonMisreads[barcode]) {
                    barcode = commonMisreads[barcode];
                    console.log('Opraveno pomoc√≠ commonMisreads:', barcode);
                } else {
                    // Fallback: zkuste generickou opravu
                    const corrected = attemptEAN8toEAN13Correction(barcode);
                    if (corrected) {
                        barcode = corrected;
                        console.log('Automaticky opraveno EAN-8 na EAN-13:', barcode);
                    }
                }
            }

            function attemptEAN8toEAN13Correction(ean8) {
                // Jednoduch√° heuristika pro opravu EAN-8 na EAN-13
                // Toto je p≈ô√≠klad - upravte podle va≈°ich pot≈ôeb
                if (ean8.startsWith('84')) {
                    return '859' + ean8.substring(2); // P≈ôid√°n√≠ prefixu 859
                }
                return null;
            }

            const calculatedChecksum = (10 - (sum % 10)) % 10;
            const isValid = calculatedChecksum === checksumDigit;

            if (!isValid) {
                console.log('Checksum neplatn√Ω:', {
                    k√≥d: barcode,
                    oƒçek√°van√Ω: checksumDigit,
                    vypoƒçten√Ω: calculatedChecksum,
                    suma: sum
                });
            }

            return isValid;
        }

        // P≈ôepnut√≠ kamery (p≈ôedn√≠/zadn√≠)
        async function toggleCamera() {
            facingMode = facingMode === 'environment' ? 'user' : 'environment';
            barcodeStatus.textContent = 'P≈ôep√≠n√°m kameru...';

            try {
                await startCamera();
                barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';

                // Restart Quagga s novou kamerou
                if (quaggaInitialized) {
                    Quagga.stop();
                    initQuagga();
                    startBarcodeScanning();
                }
            } catch (error) {
                console.error('Chyba p≈ôi p≈ôep√≠n√°n√≠ kamery:', error);
                barcodeStatus.textContent = 'Chyba: ' + error.message;
                barcodeStatus.style.color = 'red';
            }
        }

        // P≈ôepnut√≠ blesku (pokud je dostupn√Ω)
        async function toggleFlash() {
            if (!stream) return;

            const videoTrack = stream.getVideoTracks()[0];
            if (!videoTrack) return;

            try {
                const capabilities = videoTrack.getCapabilities();
                if (capabilities.torch) {
                    await videoTrack.applyConstraints({
                        advanced: [{ torch: !flashEnabled }]
                    });
                    flashEnabled = !flashEnabled;
                    document.getElementById('toggleFlashButton').textContent =
                        flashEnabled ? 'Vypnout blesk' : 'Blesk';
                } else {
                    barcodeStatus.textContent = 'Blesk nen√≠ dostupn√Ω';
                    barcodeStatus.style.color = 'orange';
                    setTimeout(() => {
                        if (barcodeModal.style.display === 'flex') {
                            barcodeStatus.textContent = 'Nami≈ôte na ƒç√°rov√Ω k√≥d';
                            barcodeStatus.style.color = '#666';
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('Chyba p≈ôi ovl√°d√°n√≠ blesku:', error);
            }
        }

        // Zav≈ôen√≠ skeneru ƒç√°rov√Ωch k√≥d≈Ø
        function closeBarcodeScanner() {
            console.log('Zav√≠r√°m skener...');

            // Zastav√≠me ƒçasov√Ω limit
            if (detectionTimeout) {
                clearTimeout(detectionTimeout);
                detectionTimeout = null;
            }

            // Zastav√≠me stream videa
            if (stream) {
                try {
                    stream.getTracks().forEach(track => {
                        track.stop();
                        console.log('Zastaven track:', track.kind);
                    });
                    stream = null;
                } catch (error) {
                    console.error('Chyba p≈ôi zastavov√°n√≠ streamu:', error);
                }
            }

            // Zastav√≠me video
            if (barcodeVideo) {
                barcodeVideo.srcObject = null;
            }

            // RESTARTUJEME QUAGGU PRO P≈ò√ç≈†T√ç POU≈ΩIT√ç
            restartQuagga();

            // Skryjeme mod√°ln√≠ okno
            barcodeModal.style.display = 'none';

            // Obnov√≠me v√Ωchoz√≠ zobrazen√≠
            document.getElementById('barcodeUnsupportedMessage').style.display = 'block';
            barcodeVideo.style.display = 'none';
            document.getElementById('toggleCameraButton').style.display = 'none';
            document.getElementById('toggleFlashButton').style.display = 'none';
            barcodeOverlay.style.display = 'none';

            console.log('Skener √∫spƒõ≈°nƒõ uzav≈ôen');
        }
        const detailsModal = document.getElementById('detailsModal');
        const closeButton = detailsModal.querySelector('.close-button');

        // Inicializace mod√°ln√≠ch oken a jejich event listener≈Ø
        document.addEventListener('DOMContentLoaded', function () {
            // Kontrola existence element≈Ø p≈ôed p≈ôid√°n√≠m event listener≈Ø
            if (!detailsModal) {
                console.error("Details modal element not found");
                return;
            }

            // Reference na mod√°ln√≠ okna a jejich ovl√°dac√≠ prvky
            const closeButton = detailsModal ? detailsModal.querySelector('.close-button') : null;
            const createRecipeModal = document.getElementById('createRecipeModal');
            const selectRecipeModal = document.getElementById('selectRecipeModal');
            const settingsModal = document.getElementById('settingsModal');
            const barcodeModal = document.getElementById('barcodeModal');

            // Event listener pro zav√≠rac√≠ tlaƒç√≠tko detailn√≠ho modalu
            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    detailsModal.style.display = 'none';
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                });
            }

            // Event listener pro zav√≠r√°n√≠ kliknut√≠m mimo mod√°ln√≠ okno
            window.addEventListener('click', (event) => {
                if (event.target == detailsModal) {
                    detailsModal.style.display = 'none';
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                }
                if (event.target == settingsModal) {
                    settingsModal.style.display = 'none';
                }
                if (event.target == selectRecipeModal) {
                    selectRecipeModal.style.display = 'none';
                }
                if (event.target == barcodeModal) {
                    closeBarcodeScanner();
                }
            });

            const createNewProfileBtn = document.getElementById('createNewProfileBtn');
            if (createNewProfileBtn) {
                createNewProfileBtn.addEventListener('click', () => {
                    document.getElementById('profileModal').style.display = 'none';
                    window.showCreateProfileModal();
                });
            }

            const confirmCreateProfile = document.getElementById('confirmCreateProfile');
            if (confirmCreateProfile) {
                confirmCreateProfile.addEventListener('click', async () => {
                    const profileName = document.getElementById('newProfileName').value.trim();
                    if (profileName) {
                        const newProfileId = await createNewProfile(profileName);
                        if (newProfileId) {
                            await selectProfile(newProfileId);
                            document.getElementById('createProfileModal').style.display = 'none';
                        }
                    }
                });
            }

            const cancelCreateProfile = document.getElementById('cancelCreateProfile');
            if (cancelCreateProfile) {
                cancelCreateProfile.addEventListener('click', () => {
                    document.getElementById('createProfileModal').style.display = 'none';
                    showProfileModal();
                });
            }

            const closeCreateProfileModal = document.getElementById('closeCreateProfileModal');
            if (closeCreateProfileModal) {
                closeCreateProfileModal.addEventListener('click', () => {
                    document.getElementById('createProfileModal').style.display = 'none';
                    showProfileModal();
                });
            }

            // Event listener pro nastavovac√≠ ikonku
            const settingsIcon = document.getElementById('settingsIcon');
            if (settingsIcon) {
                settingsIcon.addEventListener('click', () => {
                    settingsModal.style.display = 'flex';
                });
            }

            // Event listener pro tlaƒç√≠tko zav≈ôen√≠ nastaven√≠
            const closeSettingsModalButton = document.getElementById('closeSettingsModal');
            if (closeSettingsModalButton) {
                closeSettingsModalButton.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                });
            }

            // Event listener pro tlaƒç√≠tko zav≈ôen√≠ v√Ωbƒõru receptu
            const closeSelectRecipeModal = document.getElementById('closeSelectRecipeModal');
            if (closeSelectRecipeModal) {
                closeSelectRecipeModal.addEventListener('click', () => {
                    selectRecipeModal.style.display = 'none';
                });
            }

            // Event listener pro tlaƒç√≠tko zav≈ôen√≠ vytv√°≈ôen√≠ receptu
            document.getElementById('closeCreateRecipeModal').addEventListener('click', () => {
                createRecipeModal.style.display = 'none';
            });

            console.log("Mod√°ln√≠ okna inicializov√°na");
        });

        // initializeWithTimeout();

        // --- Logika vyhled√°v√°n√≠ potravin ---
        const searchForm = document.getElementById('searchForm');
        if (searchForm) {
            searchForm.addEventListener('submit', async function (event) {
                console.log('Search form submit event fired.');
                event.preventDefault();

                const query = document.getElementById('query').value;
                const resultsDiv = document.getElementById('results');
                const loadingDiv = document.getElementById('loading');
                const errorDiv = document.getElementById('error-message');

                resultsDiv.innerHTML = '';
                errorDiv.innerHTML = '';
                loadingDiv.style.display = 'block';

                // Resetujeme stav p≈ôeru≈°en√≠
                isSearchInterrupted = false;

                // Zru≈°√≠me p≈ôedchoz√≠ vyhled√°v√°n√≠, pokud existuje
                if (currentSearchController) {
                    currentSearchController.abort();
                }

                // Vytvo≈ô√≠me nov√Ω AbortController pro aktu√°ln√≠ vyhled√°v√°n√≠
                currentSearchController = new AbortController();

                try {
                    const response = await fetch('/search', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `query=${encodeURIComponent(query)}`,
                        signal: currentSearchController.signal // P≈ôipoj√≠me signal pro mo≈ænost p≈ôeru≈°en√≠
                    });

                    if (!response.ok) {
                        loadingDiv.style.display = 'none';
                        let errorData;
                        try {
                            errorData = await response.json();
                        } catch (e) {
                            errorData = { error: await response.text() };
                        }
                        errorDiv.textContent = `Chyba: ${errorData.error || response.statusText}`;
                        return;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let buffer = '';

                    while (true) {
                        // Kontrola p≈ôeru≈°en√≠ p≈ôed dal≈°√≠m ƒçten√≠m
                        if (isSearchInterrupted) {
                            console.log('Vyhled√°v√°n√≠ bylo p≈ôeru≈°eno u≈æivatelem');
                            reader.cancel();
                            break;
                        }

                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();

                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            try {
                                const item = JSON.parse(line);
                                if (item.error) {
                                    errorDiv.textContent = `Chyba ze serveru: ${item.error}`;
                                    loadingDiv.style.display = 'none';
                                    return;
                                }
                                appendFoodItem(item);
                            } catch (e) {
                                console.error('Chyba p≈ôi parsov√°n√≠ JSON ≈ô√°dku:', e, '≈ò√°dek:', line);
                            }
                        }
                    }
                    if (buffer.trim() !== '' && !isSearchInterrupted) {
                        try {
                            const item = JSON.parse(buffer);
                            if (item.error) {
                                errorDiv.textContent = `Chyba ze serveru: ${item.error}`;
                            } else {
                                appendFoodItem(item);
                            }
                        } catch (e) {
                            console.error('Chyba p≈ôi parsov√°n√≠ zbytku JSON bufferu:', e, 'Buffer:', buffer);
                        }
                    }

                    loadingDiv.style.display = 'none';
                    if (resultsDiv.innerHTML === '' && !isSearchInterrupted) {
                        resultsDiv.innerHTML = '<p>Nic nenalezeno.</p>';
                    }

                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log('Vyhled√°v√°n√≠ bylo p≈ôeru≈°eno u≈æivatelem');
                    } else {
                        console.error('Do≈°lo k chybƒõ:', error);
                        loadingDiv.style.display = 'none';
                        if (!isSearchInterrupted) {
                            errorDiv.textContent = 'Do≈°lo k chybƒõ p≈ôi komunikaci se serverem.';
                        }
                    }
                }
            });
        } else {
            console.error('Search form element with ID "searchForm" not found.');
        }

        function appendFoodItem(item) {
            // Filter out recipes - only show 'potravina'
            if (item.food_type !== 'potravina') {
                return;
            }

            const resultsDiv = document.getElementById('results');
            const foodItemDiv = document.createElement('div');
            foodItemDiv.classList.add('food-item', 'food-item-potravina');

            // Keep class for styling if needed, even if only 'potravina' is shown
            if (item.food_type === 'potravina') {
                foodItemDiv.classList.add('food-item-potravina');
            }

            if (item.slug) {
                foodItemDiv.dataset.slug = item.slug;
                foodItemDiv.dataset.foodType = item.food_type;

                // Upraven√Ω click listener pro p≈ôeru≈°en√≠ vyhled√°v√°n√≠
                foodItemDiv.addEventListener('click', () => {
                    // P≈ôeru≈°√≠me aktu√°ln√≠ vyhled√°v√°n√≠
                    isSearchInterrupted = true;
                    if (currentSearchController) {
                        currentSearchController.abort();
                    }
                    // Skryjeme loading indicator
                    document.getElementById('loading').style.display = 'none';
                    // Zobraz√≠me detaily
                    showDetailsModal(item.slug, item.name, item.image_url, item.calories, item.food_type);
                });
            }

            let imageHtml = '';
            // Updated placeholder image path
            const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";

            if (item.image_url) {
                imageHtml = `<img src="${item.image_url}" alt="${item.name}" onerror="this.onerror=null;this.src='${placeholderImage}'" />`;
            } else {
                imageHtml = `<img src="${placeholderImage}" alt="Bez obr√°zku" />`;
            }

            // Parse and reformat item.calories to ensure 1 decimal place
            const { number: caloriesNum, unit: caloriesUnit } = parseValueAndUnit(item.calories);
            const formattedCalories = formatNumberForDisplay(caloriesNum, caloriesUnit, true); // Pass true for isEnergyValue

            // Zmƒõnƒõn√° struktura pro um√≠stƒõn√≠ kalori√≠ pod obr√°zek a labelu vedle n√°zvu
            let itemContent = `
                <div class="image-wrapper">
                    ${imageHtml}
                </div>
                <div class="food-details">
                    <h3>${item.name}</h3>
                    <div class="calories-and-type-row">
                        <p class="calories-display">Kalorie: ${formattedCalories}</p>
                        <!-- Removed foodTypeLabelHtml -->
                    </div>
                </div>
            `;
            foodItemDiv.innerHTML = itemContent;
            resultsDiv.appendChild(foodItemDiv);


            // --- Logika mod√°ln√≠ho okna pro detaily potravin ---

            const modalDetailsContent = document.getElementById('modalDetailsContent');

            // References to new modals
            const createRecipeModal = document.getElementById('createRecipeModal');
            const newRecipeNameInput = document.getElementById('newRecipeNameInput');
            const confirmCreateRecipeButton = document.getElementById('confirmCreateRecipeButton');
            const cancelCreateRecipeButton = document.getElementById('cancelCreateRecipeButton');

            const selectRecipeModal = document.getElementById('selectRecipeModal');
            const existingRecipesList = document.getElementById('existingRecipesList');
            // const cancelSelectRecipeButton = document.getElementById('cancelSelectRecipeButton'); // Removed
            // const addNewRecipeButton = document.getElementById('addNewRecipeButton'); // Removed

            // References to settings modal elements
            const settingsIcon = document.getElementById('settingsIcon');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsModalButton = document.getElementById('closeSettingsModal');
            const confirmRecipeCreationToggle = document.getElementById('confirmRecipeCreationToggle'); // New toggle
            const confirmFoodAdditionToggle = document.getElementById('confirmFoodAdditionToggle'); // New toggle
            const confirmDeleteRecipeToggle = document.getElementById('confirmDeleteRecipeToggle'); // New toggle for delete confirmation
            const confirmDeleteRecipeItemToggle = document.getElementById('confirmDeleteRecipeItemToggle'); // NEW toggle
            const confirmSaveChangesToggle = document.getElementById('confirmSaveChangesToggle'); // NEW
            const confirmRecipeSaveSuccessToggle = document.getElementById('confirmRecipeSaveSuccessToggle'); // NEW

            // currentFoodItemData is now in global scope
            // let currentFoodItemData = null; // To store data of the food item being processed

            // Event listener for the toggle switch in the settings modal for recipe creation
            if (confirmRecipeCreationToggle) {
                confirmRecipeCreationToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeCreation = confirmRecipeCreationToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ vytvo≈ôen√≠ receptu povoleno:", userSettings.confirmRecipeCreation);
                });
            }

            // Event listener for the toggle switch in the settings modal for food addition
            if (confirmFoodAdditionToggle) {
                confirmFoodAdditionToggle.addEventListener('change', () => {
                    userSettings.confirmFoodAddition = confirmFoodAdditionToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ p≈ôid√°n√≠ potraviny povoleno:", userSettings.confirmFoodAddition);
                });
            }

            // Event listener for the toggle switch in the settings modal for delete confirmation
            if (confirmDeleteRecipeToggle) {
                confirmDeleteRecipeToggle.addEventListener('change', () => {
                    userSettings.confirmDeleteRecipe = confirmDeleteRecipeToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ smaz√°n√≠ receptu povoleno:", userSettings.confirmDeleteRecipe);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for recipe item deletion
            if (confirmDeleteRecipeItemToggle) {
                confirmDeleteRecipeItemToggle.addEventListener('change', () => {
                    userSettings.confirmDeleteRecipeItem = confirmDeleteRecipeItemToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ smaz√°n√≠ polo≈æky povoleno:", userSettings.confirmDeleteRecipeItem);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for save changes confirmation
            if (confirmSaveChangesToggle) {
                confirmSaveChangesToggle.addEventListener('change', () => {
                    userSettings.confirmSaveChanges = confirmSaveChangesToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Potvrzen√≠ ulo≈æen√≠ zmƒõn povoleno:", userSettings.confirmSaveChanges);
                });
            }

            // NEW: Event listener for the toggle switch in the settings modal for successful save notification
            if (confirmRecipeSaveSuccessToggle) {
                confirmRecipeSaveSuccessToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeSaveSuccess = confirmRecipeSaveSuccessToggle.checked;
                    saveUserSettings(); // Save to Firestore
                    console.log("Ozn√°men√≠ √∫spƒõ≈°n√©ho ulo≈æen√≠ zmƒõn povoleno:", userSettings.confirmRecipeSaveSuccess);
                });
            }

            // New toggle for successful recipe deletion notification
            const confirmRecipeDeletionSuccessToggle = document.getElementById('confirmRecipeDeletionSuccessToggle');
            if (confirmRecipeDeletionSuccessToggle) {
                confirmRecipeDeletionSuccessToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeDeletionSuccess = confirmRecipeDeletionSuccessToggle.checked;
                    saveUserSettings();
                    console.log("Potvrzen√≠ √∫spƒõ≈°n√©ho smaz√°n√≠ povoleno:", userSettings.confirmRecipeDeletionSuccess);
                });
            }

            // New toggle for recipe deletion error notification
            const confirmRecipeDeletionErrorToggle = document.getElementById('confirmRecipeDeletionErrorToggle');
            if (confirmRecipeDeletionErrorToggle) {
                confirmRecipeDeletionErrorToggle.addEventListener('change', () => {
                    userSettings.confirmRecipeDeletionError = confirmRecipeDeletionErrorToggle.checked;
                    saveUserSettings();
                    console.log("Potvrzen√≠ chyby smaz√°n√≠ povoleno:", userSettings.confirmRecipeDeletionError);
                });
            }

            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    detailsModal.style.display = 'none';
                    // Reset current editing context when closing the modal
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                });
            }

            window.addEventListener('click', (event) => {
                if (event.target == detailsModal) {
                    detailsModal.style.display = 'none';
                    // Reset current editing context when closing the modal
                    currentEditingRecipeId = null;
                    currentEditingIngredientIndex = null;
                }
                if (event.target == settingsModal) { // Close settings modal if clicked outside
                    settingsModal.style.display = 'none';
                }
                // Close custom notification modal if clicked outside, unless it's a confirmation type
                if (event.target == customNotificationModal && customNotificationModal.style.display === 'flex') {
                    // If it's a confirmation, don't close on outside click.
                    // This requires a way to know if it's a confirmation.
                    // For now, let's assume all custom notifications can be closed by outside click.
                    // A more robust solution would be to add a data attribute to the modal when it's a confirmation.
                    customNotificationModal.style.display = 'none';
                }
                // Close selectRecipeModal if clicked outside
                if (event.target == selectRecipeModal) {
                    selectRecipeModal.style.display = 'none';
                }
                // Close barcodeModal if clicked outside
                if (event.target == barcodeModal) {
                    closeBarcodeScanner();
                }
            });

            // Close new modals
            document.getElementById('closeCreateRecipeModal').addEventListener('click', () => {
                createRecipeModal.style.display = 'none';
            });

            // Event listener for confirming new recipe creation
            if (confirmCreateRecipeButton) { // Add check for existence
                confirmCreateRecipeButton.onclick = async () => {
                    const recipeName = newRecipeNameInput.value.trim();
                    if (recipeName) {
                        await createNewRecipe(recipeName, currentFoodItemData);
                        createRecipeModal.style.display = 'none';
                    } else {
                        window.showCustomNotification("Pros√≠m, zadejte n√°zev receptu.", 'validationError');
                    }
                };
            }

            // Event listener for canceling new recipe creation
            if (cancelCreateRecipeButton) { // Add check for existence
                cancelCreateRecipeButton.addEventListener('click', () => {
                    createRecipeModal.style.display = 'none';
                });
            }

            document.getElementById('closeSelectRecipeModal').addEventListener('click', () => {
                selectRecipeModal.style.display = 'none';
            });

            // Settings icon click listener
            if (settingsIcon) {
                settingsIcon.addEventListener('click', () => {
                    settingsModal.style.display = 'flex';
                });
            }

            // Close settings modal button
            if (closeSettingsModalButton) {
                closeSettingsModalButton.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                });
            }

        }; // End of DOMContentLoaded

        async function showDetailsModal(slug, name, imageUrl, initialCaloriesString, foodType, isEditingRecipeIngredient = false, initialAmount = 100, initialUnit = 'g', originalNutritionalDetails = null) {
            console.log("showDetailsModal called for slug:", slug, "name:", name, "foodType:", foodType, "isEditingRecipeIngredient:", isEditingRecipeIngredient);
            modalDetailsContent.classList.remove('modal-recipe-container'); // Odebere t≈ô√≠du pro potraviny
            document.getElementById('modalDetailsContent').classList.remove('modal-recipe-container');
            document.getElementById('detailsModal').classList.remove('modal-recipe-open');
            detailsModal.style.display = 'flex'; // Ensure modal is visible
            modalDetailsContent.innerHTML = `<p class="loading-details">Naƒç√≠t√°m detaily pro ${name}...</p>`;

            try {
                let details;
                if (isEditingRecipeIngredient && originalNutritionalDetails) {
                    // If editing an ingredient, use the provided nutritional details directly
                    details = originalNutritionalDetails;
                    console.log("Using provided nutritional details for editing:", details);
                } else {
                    // Otherwise, fetch details from the server
                    const response = await fetch('/get_details', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ slug: slug, food_type: foodType })
                    });

                    console.log("Response status:", response.status);

                    if (!response.ok) {
                        let errorMessage = `Chyba p≈ôi naƒç√≠t√°n√≠ detail≈Ø (Status: ${response.status}).`;
                        let rawResponseText = await response.text();
                        console.error("Raw server response (not OK):", rawResponseText);
                        try {
                            const errorData = JSON.parse(rawResponseText);
                            if (errorData && errorData.error) {
                                errorMessage = `Chyba ze serveru: ${errorData.error}`;
                            } else {
                                errorMessage = `Chyba ze serveru (nezn√°m√Ω form√°t odpovƒõdi).`;
                            }
                        } catch (jsonParseError) {
                            errorMessage = `Chyba p≈ôi komunikaci se serverem: ${response.statusText || 'Nezn√°m√° chyba'}. Odpovƒõƒè serveru nebyla platn√Ω JSON.`;
                            console.error("Nepoda≈ôilo se parsovat odpovƒõƒè serveru jako JSON:", jsonParseError);
                        }
                        modalDetailsContent.innerHTML = `<p class="error-details">${errorMessage}</p>`;
                        return;
                    }
                    details = await response.json();
                    console.log("Received details JSON:", details);
                }

                let originalDetailsData = details;

                if (details.error) {
                    modalDetailsContent.innerHTML = `<p class="error-details">Chyba ze serveru: ${details.error}</p>`;
                } else {
                    // Updated placeholder image path
                    const placeholderImage = "{{ url_for('static', filename='icon/potraviny.png') }}";
                    let displayImageUrl = imageUrl || placeholderImage;

                    const { unit: initialUnitForTypeDetection } = parseValueAndUnit(initialCaloriesString);
                    const isLiquidFood = initialUnitForTypeDetection.toLowerCase().includes('ml');

                    let actionButtonsHtml = '';
                    if (isEditingRecipeIngredient) {
                        actionButtonsHtml = `
                            <div class="modal-action-buttons">
                                <button id="saveChangesButton" style="background-color: #28a745;">Ulo≈æit zmƒõny</button>
                                <button id="discardChangesButton" style="background-color: #dc3545;">Zahodit zmƒõny</button>
                            </div>
                        `;
                    } else {
                        actionButtonsHtml = `
                            <div class="modal-action-buttons">
                                <button id="addToRecipeButton">P≈ôidat do receptu</button>
                                <button id="createAndAddRecipeButton">Vytvo≈ôit recept a p≈ôidat</button>
                            </div>
                        `;
                    }

                    let detailsHtml = `
                        <div class="modal-header-content">
                            <img id="modalHeaderImage" src="${displayImageUrl}" alt="${name}" class="modal-header-image" onerror="this.onerror=null;this.src='${placeholderImage}'" />
                            <div id="modalHeaderName" class="modal-header-name">${name}</div>
                        </div>
                        ${actionButtonsHtml}
                        <div class="interactive-section">
                            <div class="amount-controls">
                                <input type="number" id="amountInput" value="${initialAmount}" min="0" step="1" class="amount-input">
                                <select id="unitSelect" class="unit-select">
                                    <!-- Options will be dynamically added here -->
                                </select>
                            </div>
                            <div class="energy-display-group">
                                <div id="totalKcalDisplay" class="energy-header"></div>
                                <div id="totalKjDisplay" class="energy-sub-header"></div>
                            </div>
                        </div>
                        <div id="nutrientDetailsSection">
                            <!-- Nutrients will be rendered here by renderAllNutrientDetails -->
                        </div>
                        ${details.source_url ? `<p style="text-align: center; margin-top: 20px;"><a href="${details.source_url}" target="_blank">Zobrazit na Kalorick√©Tabulky.cz</a></p>` : ''}
                    `;
                    modalDetailsContent.innerHTML = detailsHtml;

                    // Re-get references to elements after innerHTML is set
                    const amountInput = document.getElementById('amountInput');
                    const unitSelect = document.getElementById('unitSelect');
                    const addToRecipeButton = document.getElementById('addToRecipeButton'); // May be null
                    const createAndAddRecipeButton = document.getElementById('createAndAddRecipeButton'); // May be null
                    const saveChangesButton = document.getElementById('saveChangesButton'); // May be null
                    const discardChangesButton = document.getElementById('discardChangesButton'); // May be null

                    unitSelect.innerHTML = '';
                    if (isLiquidFood) {
                        unitSelect.add(new Option('ml', 'ml'));
                        unitSelect.add(new Option('l', 'l'));
                        unitSelect.value = initialUnit;
                    } else {
                        unitSelect.add(new Option('g', 'g'));
                        unitSelect.add(new Option('kg', 'kg'));
                        unitSelect.value = initialUnit;
                    }

                    const updateDisplay = () => {
                        const currentAmount = parseFloat(amountInput.value) || 0;
                        const selectedUnit = unitSelect.value;
                        let baseAmount = currentAmount;

                        if (selectedUnit === 'kg') {
                            baseAmount = currentAmount * 1000;
                        } else if (selectedUnit === 'l') {
                            baseAmount = currentAmount * 1000;
                        }

                        let factor = baseAmount / 100;

                        renderAllNutrientDetails(originalDetailsData, factor);

                        // Update currentFoodItemData with the latest calculated values for saving/adding
                        currentFoodItemData = {
                            foodName: name,
                            slug: slug,
                            imageUrl: displayImageUrl,
                            foodType: foodType,
                            amount: currentAmount,
                            unit: selectedUnit,
                            kcal: document.getElementById('totalKcalDisplay').textContent, // Store the calculated kcal
                            nutritionalDetails: originalDetailsData // Store the full nutritional details
                        };
                    };

                    amountInput.addEventListener('input', updateDisplay);
                    unitSelect.addEventListener('change', updateDisplay);

                    updateDisplay(); // Initial display update

                    // Event listeners for buttons
                    if (addToRecipeButton) {
                        addToRecipeButton.addEventListener('click', async (e) => {
                            e.stopPropagation();

                            if (!checkInitialization()) {
                                return;
                            }

                            console.log('P≈ôidat do receptu clicked for:', name);
                            await loadUserRecipes(true);
                            detailsModal.style.display = 'none';
                            selectRecipeModal.style.display = 'flex';
                        });
                    }

                    if (createAndAddRecipeButton) {
                        createAndAddRecipeButton.addEventListener('click', (e) => {
                            e.stopPropagation();

                            if (!checkInitialization()) {
                                return;
                            }

                            console.log('Vytvo≈ôit recept a p≈ôidat clicked for:', name);
                            detailsModal.style.display = 'none';
                            createRecipeModal.style.display = 'flex';
                            newRecipeNameInput.value = '';
                            newRecipeNameInput.focus();
                        });
                    }

                    if (saveChangesButton) {
                        saveChangesButton.addEventListener('click', async () => {
                            if (currentEditingRecipeId && currentEditingIngredientIndex !== null) {
                                await updateFoodItemInRecipe(currentEditingRecipeId, currentEditingIngredientIndex, currentFoodItemData);
                                // The modal closing and recipe details reloading is now handled within updateFoodItemInRecipe's success callback
                            } else {
                                window.showCustomNotification("Chyba: Nelze ulo≈æit zmƒõny. Chyb√≠ kontext √∫pravy.", 'info');
                            }
                        });
                    }

                    if (discardChangesButton) {
                        discardChangesButton.addEventListener('click', async () => {
                            detailsModal.style.display = 'none';
                            // Optionally, reload the original recipe details if needed
                            if (currentEditingRecipeId) {
                                const recipeDocRef = doc(db, `artifacts/${appId}/profiles/${currentProfileId}/recipes`, currentEditingRecipeId);
                                const recipeSnap = await getDoc(recipeDocRef);
                                if (recipeSnap.exists()) {
                                    await showRecipeDetailsModal(currentEditingRecipeId, recipeSnap.data().name);
                                }
                            }
                            // Reset current editing context
                            currentEditingRecipeId = null;
                            currentEditingIngredientIndex = null;
                        });
                    }

                    const modalHeaderImage = document.getElementById('modalHeaderImage');
                    const modalHeaderName = document.getElementById('modalHeaderName');

                    if (modalHeaderImage && modalHeaderName) {
                        const imageHeight = modalHeaderImage.offsetHeight;
                        let currentFontSize = imageHeight * 0.25;
                        modalHeaderName.style.fontSize = `${currentFontSize}px`;

                        while ((modalHeaderName.scrollWidth > modalHeaderName.clientWidth || modalHeaderName.scrollHeight > modalHeaderName.clientHeight) && currentFontSize > 10) {
                            currentFontSize -= 0.5;
                            modalHeaderName.style.fontSize = `${currentFontSize}px`;
                        }
                    }
                }

            } catch (error) {
                console.error('Chyba p≈ôi z√≠sk√°v√°n√≠ detail≈Ø:', error);
                modalDetailsContent.innerHTML = `<p class="error-details">Do≈°lo k chybƒõ p≈ôi komunikaci se serverem pro detaily.</p>`;
            }
        }

        // --- Logika pro tlaƒç√≠tko "Recepty" a mod√°ln√≠ okno s mo≈ænostmi recept≈Ø ---
        const recipesButton = document.getElementById('recipesButton');

        // Modified recipesButton listener
        if (recipesButton) {
            recipesButton.addEventListener('click', async () => {
                try {
                    await waitForInitialization();
                    await loadUserRecipes();
                    selectRecipeModal.style.display = 'flex';
                } catch (error) {
                    window.showCustomNotification("Aplikace nen√≠ p≈ôipravena. Zkuste to pros√≠m znovu.", 'error');
                }
            });
        }

        // Na konec souboru p≈ôidejte/upravte
        console.log("‚úÖ Script naƒçten, ƒçek√°m na DOM...");

        // Jedin√° inicializace p≈ôi naƒçten√≠ DOM
        document.addEventListener('DOMContentLoaded', async function () {
            console.log("‚úÖ DOM naƒçten, spou≈°t√≠m aplikaci...");

            // Kontrola, zda ji≈æ nebyla inicializov√°na
            if (window.appInitialized) {
                console.log("‚ö†Ô∏è Aplikace ji≈æ byla inicializov√°na - p≈ôeskoƒçeno");
                return;
            }

            window.appInitialized = true;
            await initializeApplication();
        });

    </script>

    <!-- Load QuaggaJS for barcode scanning -->
    <script src="https://cdn.jsdelivr.net/npm/quagga@0.12.1/dist/quagga.min.js"></script>
</body>

</html>